{
  "name": "ScreenNotes v.4.5",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "message"
        ],
        "additionalFields": {
          "download": false
        }
      },
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.2,
      "position": [
        -176,
        80
      ],
      "id": "8d0c6c28-abae-48fa-aab0-90814ff26f94",
      "name": "Start",
      "webhookId": "5428366b-57a2-4c0c-998e-e27ee0fc177b",
      "credentials": {
        "telegramApi": {
          "id": "VOYibrgljcdGx8q9",
          "name": "ScreenNotes"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * extract_file_id (uses ONLY $items('start'))\n * - Reads Telegram update strictly from $items('start')[0].json\n * - Priority: largest photo → document → video → animation → sticker\n * - Returns: { chat_id, file_id, caption, file_name, content_kind, has_media, token }\n */\n\nfunction largestPhoto(photos) {\n  if (!Array.isArray(photos) || photos.length === 0) return null;\n  const sorted = [...photos].sort((a, b) => (a.file_size || 0) - (b.file_size || 0));\n  return sorted.at(-1) || null;\n}\n\nfunction firstText(...vals) {\n  for (const v of vals) if (typeof v === 'string' && v.trim()) return v;\n  return '';\n}\n\n// 1) Strictly use the Start node payload\nconst startItem = $items('Start')?.[0]?.json || {};\n\n// 2) Pick the effective Telegram message object from Start\n//    (covers common Telegram update shapes)\nconst m =\n  startItem.message ||\n  startItem.edited_message ||\n  startItem.channel_post ||\n  startItem.edited_channel_post ||\n  (startItem.callback_query ? startItem.callback_query.message : null) ||\n  {};\n\n// 3) Extract chat_id\nconst chat_id =\n  (m.chat && typeof m.chat.id !== 'undefined') ? m.chat.id :\n  (startItem.callback_query && startItem.callback_query.from && typeof startItem.callback_query.from.id !== 'undefined')\n    ? startItem.callback_query.from.id\n    : null;\n\n// 4) Extract media file_id by priority\nlet file_id = null;\nlet content_kind = null;\n\nconst ph = largestPhoto(m.photo);\nif (ph?.file_id) {\n  file_id = ph.file_id;\n  content_kind = 'photo';\n} else if (m.document?.file_id) {\n  file_id = m.document.file_id;\n  content_kind = 'document';\n} else if (m.video?.file_id) {\n  file_id = m.video.file_id;\n  content_kind = 'video';\n} else if (m.animation?.file_id) {\n  file_id = m.animation.file_id;\n  content_kind = 'animation';\n} else if (m.sticker?.file_id) {\n  file_id = m.sticker.file_id;\n  content_kind = 'sticker';\n}\n\n// 5) Caption/text and a reasonable file name\nconst caption = firstText(m.caption, m.text);\nconst file_name =\n  m?.document?.file_name ||\n  m?.video?.file_name ||\n  (content_kind === 'photo' ? `photo_${Date.now()}.jpg` : `file_${Date.now()}`);\n\n// 6) Read token ONLY from init_config\nconst token = $items('init_config')?.[0]?.json?.TELEGRAM_BOT_TOKEN || null;\n\n// 7) Output\nreturn [{\n  json: {\n    chat_id,\n    file_id,\n    caption,\n    file_name,\n    content_kind,\n    has_media: !!file_id,\n    token\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        608
      ],
      "id": "9838846c-ace0-402a-b50c-4a8cf45c0087",
      "name": "extract_file_id"
    },
    {
      "parameters": {
        "url": "=https://api.telegram.org/bot{{ $json.token }}/getFile",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "=file_id",
              "value": "={{ $json.file_id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        256,
        608
      ],
      "id": "32b4598c-e68d-4df7-95e0-8f2abb664578",
      "name": "getFile"
    },
    {
      "parameters": {
        "url": "=https://api.telegram.org/file/bot8349012441:AAF0_PdT0ltnkii1uX9_L9mm0-o20dZuMuo/{{$json.result.file_path}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "screenshot"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        672,
        608
      ],
      "id": "cfc13334-0ff3-480f-9bb6-008a94157b42",
      "name": "downloadFile"
    },
    {
      "parameters": {
        "jsCode": "/**\n * normalize_for_notion (v3.8)\n * - Без хардкода: берёт init_config + всё из апстрима (LLM/сервисные ноды), сливает и нормализует.\n * - Поддержка UID из ноды Crypto/crypto (ImageUID/UID/hash/sha256/sha1/md5) → потом UID/file_unique_id → fallback-хэш.\n * - Резолвит screenshot_url (tg/gdrive/llm), прокидывает rootFolderId, ScreenShotFile.\n * - Прокидывает вниз NOTION_DATABASE_ID (из pick_db_by_name → found_db_id), а также database_id/db_id алиасы.\n * - Возвращает плоский JSON + init_config.\n */\n\n/************ Small utils ************/\nconst nonEmpty = v => (v!==null && v!==undefined && (typeof v!=='string' || v.trim()!=='') && (!Array.isArray(v) || v.length>0));\nconst isObj = v => v && typeof v === 'object' && !Array.isArray(v);\nconst toStr = v => (v==null ? '' : String(v));\nfunction safe(getter, dflt){ try { const v = getter(); return v === undefined ? dflt : v; } catch { return dflt; } }\nfunction hashStr(s){ s = String(s || ''); let h = 5381; for (let i=0;i<s.length;i++) h = ((h<<5)+h)+s.charCodeAt(i); return (h>>>0).toString(16); }\n\nfunction toNumber(v){\n  if (v == null || v === '') return undefined;\n  if (typeof v === 'number' && isFinite(v)) return v;\n  const s = String(v).trim().replace(/\\s+/g, '').replace(',', '.');\n  const n = Number(s);\n  return isFinite(n) ? n : undefined;\n}\nfunction upper(v){ if (!nonEmpty(v) && v !== 0) return undefined; return String(v).trim().toUpperCase(); }\n\n/************ Dates ************/\nfunction toIsoDate(v){\n  if (!v) return undefined;\n  if (typeof v === 'string'){\n    const s = v.trim();\n    if (/^\\d{4}-\\d{2}-\\d{2}/.test(s)) return s.slice(0,10);\n    const dm = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/);\n    if (dm) return `${dm[3]}-${dm[2]}-${dm[1]}`;\n    const d = new Date(s);\n    if (!isNaN(+d)) return d.toISOString().slice(0,10);\n    return undefined;\n  }\n  if (v instanceof Date && !isNaN(+v)) return v.toISOString().slice(0,10);\n  return undefined;\n}\nfunction buildNotionDate(input){\n  if (!input) return undefined;\n  if (typeof input === 'string' || input instanceof Date){\n    const start = toIsoDate(input);\n    return start ? { start, end: null } : undefined;\n  }\n  const start = toIsoDate(input.start);\n  const end = toIsoDate(input.end);\n  if (!start && !end) return undefined;\n  return { start: start || undefined, end: end || null };\n}\n\n/************ Lists / bool ************/\nfunction toMulti(val){\n  if (val == null) return undefined;\n  if (Array.isArray(val)) return val.filter(nonEmpty).map(v=>String(v).trim());\n  const s = String(val);\n  if (s.includes(',')) return s.split(',').map(x=>x.trim()).filter(nonEmpty);\n  const one = s.trim();\n  return one ? [one] : undefined;\n}\nfunction boolish(v){\n  if (typeof v === 'boolean') return v;\n  const s = String(v).trim().toLowerCase();\n  if (['true','yes','1','y','on'].includes(s)) return true;\n  if (['false','no','0','n','off'].includes(s)) return false;\n  return !!v;\n}\n\n/************ Flatten + merge ************/\nfunction flatten(obj, out = {}) {\n  if (!isObj(obj)) return out;\n  for (const [k, v] of Object.entries(obj)) {\n    out[k] = v;\n    if (isObj(v) && ['data','payload','record','result','results','properties','output'].includes(k)) {\n      for (const [kk, vv] of Object.entries(v)) if (out[kk] === undefined) out[kk] = vv;\n    }\n  }\n  return out;\n}\nfunction mergedData(){\n  const all = $input.all() || [];\n  const sources = [\n    ...all.map(i => i.json),\n    $json,\n    safe(()=> $items('gd_output')[0].json, null),\n    safe(()=> $items('build_tgURL')[0].json, null),\n    safe(()=> $items('getFile')[0].json, null),\n  ].filter(Boolean);\n  const m = {};\n  for (const s of sources) flatten(s, m);\n  return m;\n}\n\n/************ Init config ************/\nfunction pickInit(){\n  return safe(()=> $items('init_config')[0].json, null)\n      || safe(()=> $json.init_config, null)\n      || null;\n}\nconst cfg = pickInit() || {};\nconst fieldsCfgArray = Array.isArray(cfg.fields) ? cfg.fields : []; // если массив\nconst ndbProps = isObj(cfg.NOTION_DB_PROPERTIES) ? cfg.NOTION_DB_PROPERTIES : null; // если объект схемы\nconst allowedTypes = safe(()=> (cfg.typeOptions?.Type?.select?.options || []).map(o => o.name), []);\nconst SCREEN_ROOT_ID = cfg.routes?.screenRootId || '1TD-SOF7vE5EnYwhwils2GFIFT5mQwlAP';\n\n/************ DB ID resolver (pick_db_by_name first) ************/\nfunction pickDbIdFromFlow(){\n  const byName = safe(()=> $items('pick_db_by_name')[0].json, null);\n  if (byName?.found_db_id) return byName.found_db_id;\n  if ($json?.NOTION_DATABASE_ID) return $json.NOTION_DATABASE_ID;\n  if ($json?.database_id)       return $json.database_id;\n  if ($json?.db_id)             return $json.db_id;\n  if (cfg?.database_id)         return cfg.database_id;\n  const all = $input.all() || [];\n  for (const it of all){\n    const j = it.json || {};\n    if (j.found_db_id) return j.found_db_id;\n    if (j.database_id) return j.database_id;\n    if (j.db_id)       return j.db_id;\n  }\n  return null;\n}\n\n/************ Screenshot candidates (LLM/TG/GDrive) ************/\nconst file_name =\n  safe(()=> $node['build_tgURL'].json.file_name, null) ||\n  safe(()=> $items('build_tgURL')[0].json.file_name, null) ||\n  safe(()=> $json.file_name, 'file');\n\nconst token =\n  safe(()=> $node['extract_file_id'].json.token, null) ||\n  safe(()=> $items('extract_file_id')[0].json.token, null);\n\nfunction pickScreenshotURL(data){\n  const cand = [\n    data.screenshot_url,\n    data.ScreenshotUrl,\n    data.preview_url,\n    data.image_url,\n    data.file_url,\n    data.thumb_url,\n    data.gdrive_view_url,\n  ].filter(nonEmpty);\n\n  const tg_direct =\n    safe(()=> $items('build_tgURL')[0].json.tg_file_url, null) ||\n    (token && safe(()=> $items('getFile')[0].json.result.file_path, null)\n      ? `https://api.telegram.org/file/bot${token}/${$items('getFile')[0].json.result.file_path}`\n      : null) ||\n    (token && data.file_path ? `https://api.telegram.org/file/bot${token}/${data.file_path}` : null);\n\n  if (tg_direct) cand.unshift(tg_direct);\n\n  if (nonEmpty(data.gdrive_file_id)){\n    const id = data.gdrive_file_id;\n    cand.unshift(`https://drive.google.com/uc?export=view&id=${id}`);\n    cand.unshift(`https://drive.google.com/thumbnail?id=${id}&sz=w2048`);\n  }\n\n  const uniq = [...new Set(cand)];\n  return uniq[0] || undefined;\n}\n\n/************ UID resolver (Crypto node / data / fallback) ************/\nfunction pickUID(data){\n  const cryptoJ =\n    safe(()=> $items('Crypto')[0].json, null) ||\n    safe(()=> $items('crypto')[0].json, null) ||\n    safe(()=> $node['Crypto'].json, null)     ||\n    safe(()=> $node['crypto'].json, null);\n\n  const fromCrypto =\n    cryptoJ?.ImageUID || cryptoJ?.imageUID ||\n    cryptoJ?.UID      || cryptoJ?.uid      ||\n    cryptoJ?.hash     || cryptoJ?.sha256   ||\n    cryptoJ?.sha1     || cryptoJ?.md5      || null;\n\n  const fromData =\n    data.UID || data.uid ||\n    data.imageUID || data.image_uid ||\n    data.file_unique_id || data.file_id || null;\n\n  if (fromCrypto) return String(fromCrypto);\n  if (fromData)   return String(fromData);\n\n  const raw = [\n    data['Source URL'] || data.source_url || '',\n    data.screenshot_url || data.ScreenshotUrl || '',\n    data.file_name || data.ScreenShotFile || '',\n    data.file_size || '',\n    data.Title || data.title || ''\n  ].join('|');\n  return hashStr(raw);\n}\n\n/************ Type inference ************/\nfunction inferType(name, value){\n  const s = String(name||'').toLowerCase();\n  if (s.includes('url') || /^https?:\\/\\//i.test(value||'')) return 'url';\n  if (s.endsWith('_email') || s === 'email') return 'email';\n  if (s.endsWith('_phone') || s === 'phone') return 'phone_number';\n  if (s.includes('date') || s.endsWith('_at') || s.endsWith('date')) return 'date';\n  if (s.includes('price') || s.includes('amount') || typeof value === 'number') return 'number';\n  if (s.includes('tags') || s.includes('labels') || Array.isArray(value)) return 'multi_select';\n  if (s.includes('currency') || s.includes('status') || s.endsWith('type') || s.includes('category') || s.includes('lang') || s.includes('channel')) return 'select';\n  if (s.includes('screenshot') || s.endsWith('_file') || s.endsWith('_image')) return 'files';\n  if (s.includes('checkbox') || typeof value === 'boolean') return 'checkbox';\n  if (s === 'title' || s === 'name') return 'title';\n  return 'rich_text';\n}\nfunction normalizeByType(t, val){\n  switch (t) {\n    case 'number': return toNumber(val);\n    case 'date':\n      if (val && typeof val === 'object' && ('start' in val || 'end' in val)) return buildNotionDate(val);\n      return buildNotionDate(val) || undefined;\n    case 'select': return nonEmpty(val) ? toStr(val) : undefined;\n    case 'multi_select': return toMulti(val);\n    case 'url': return nonEmpty(val) ? toStr(val) : undefined;\n    case 'email': return nonEmpty(val) ? toStr(val) : undefined;\n    case 'phone_number': return nonEmpty(val) ? toStr(val) : undefined;\n    case 'checkbox': return !!boolish(val);\n    case 'files': return nonEmpty(val) ? toStr(val) : undefined; // URL string\n    case 'title': return nonEmpty(val) ? toStr(val) : undefined;\n    default: return nonEmpty(val) ? toStr(val) : undefined;\n  }\n}\n\n/************ Build normalized payload ************/\nconst data = mergedData();\nconst out = {};\nconst usedKeys = new Set();\n\n// 0) Если init_config содержит объект схемы NOTION_DB_PROPERTIES — построим локальную карту типов (по желанию)\nconst cfgMap = {};\nif (ndbProps){\n  for (const [k, schema] of Object.entries(ndbProps)){\n    if (!isObj(schema)) continue;\n    const [t] = Object.keys(schema); // title / select / number / date / ...\n    if (t) cfgMap[k] = t;\n  }\n}\n\n// 1) Сначала — поля из init_config.fields (если это массив имён/описаний полей)\nfor (const f of (fieldsCfgArray || [])){\n  const name = f?.name || f?.notion || f?.src;\n  if (!name) continue;\n  const src  = f?.src || name;\n  const raw  = (data[src] !== undefined) ? data[src] : data[name];\n  const type = f?.type || cfgMap[name] || inferType(name, raw);\n\n  let v = raw;\n  if ((!nonEmpty(v)) && type === 'files' && /screenshot/i.test(name)) v = pickScreenshotURL(data);\n\n  const norm = normalizeByType(type, v);\n  if (norm !== undefined){ out[name] = norm; usedKeys.add(src); usedKeys.add(name); }\n}\n\n// 2) Если из пункта (1) ничего не пришло — ориентируемся на ndbProps (объект схемы)\nif (Object.keys(out).length === 0 && Object.keys(cfgMap).length){\n  for (const [name, type] of Object.entries(cfgMap)){\n    const raw = (data[name] !== undefined) ? data[name] : data[name];\n    let v = raw;\n    if ((!nonEmpty(v)) && type === 'files' && /screenshot/i.test(name)) v = pickScreenshotURL(data);\n    const norm = normalizeByType(type, v);\n    if (norm !== undefined){ out[name] = norm; usedKeys.add(name); }\n  }\n}\n\n// 3) Title (если не задан)\nif (out.Title == null){\n  const titleCand = data.Title ?? data.title ?? data.Name ?? data.name ?? data.caption ?? 'Untitled';\n  out.Title = toStr(titleCand);\n  usedKeys.add('Title'); usedKeys.add('title'); usedKeys.add('Name'); usedKeys.add('name');\n}\n\n// 4) Type (ограничиваем списком из init_config, если он есть)\nif (allowedTypes?.length){\n  const proposed = data.Type ?? data.type ?? 'Note';\n  out.Type = allowedTypes.includes(proposed) ? proposed : 'Note';\n  usedKeys.add('Type'); usedKeys.add('type');\n} else if (data.Type || data.type){\n  out.Type = toStr(data.Type ?? data.type);\n  usedKeys.add('Type'); usedKeys.add('type');\n}\n\n// 5) UID (Crypto → data → fallback hash)\nout['UID'] = pickUID(data);\n\n// 6) Автодобавление остальных ключей (инференс)\nconst SKIP = new Set([\n  'id','object','url','cover','icon','parent','archived','created_time','last_edited_time',\n  'properties','results','result','payload','data','output','method','body','headers',\n  'database_id','db_id','found_db_id','found_db_url','found_title','requested_name',\n  'file_id','file_path','tg_file_url','token',\n  'gdrive_file_id','gdrive_view_url',\n]);\nfor (const [k,v] of Object.entries(data)){\n  if (usedKeys.has(k) || SKIP.has(k)) continue;\n  if (!nonEmpty(v)) continue;\n  if (out[k] !== undefined) continue;\n  const type = cfgMap[k] || inferType(k, v);\n  const norm = normalizeByType(type, v);\n  if (norm !== undefined) out[k] = norm;\n}\n\n// 7) Screenshot/screenshot_url (если ещё нет)\nconst bestShot = pickScreenshotURL({ ...data, ScreenshotUrl: out.Screenshot ?? data.ScreenshotUrl });\nif (bestShot && !out.Screenshot && !out.screenshot_url){\n  const hasScreenshotProp =\n    (fieldsCfgArray || []).some(f => (f?.type === 'files' && /screenshot/i.test(f?.name || f?.src || ''))) ||\n    Object.keys(cfgMap).some(k => /screenshot/i.test(k) && cfgMap[k]==='files');\n  if (hasScreenshotProp) out['Screenshot'] = bestShot;\n  else out['screenshot_url'] = bestShot;\n}\n\n// 8) Лёгкая нормализация частых полей\nif (out.Currency != null) out.Currency = upper(out.Currency);\nif (data.currency != null && out.Currency == null) out.Currency = upper(data.currency);\nif (!out['Map URL'] && (out.Address || data.address)){\n  out['Map URL'] = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(out.Address || data.address)}`;\n}\n\n// 9) Сервис для GDrive и таймштамп\nout['ScreenShotFile'] = file_name || 'file';\nout['rootFolderId']   = SCREEN_ROOT_ID;\nout['Captured at']    = new Date().toISOString();\n\n// 10) Проложим init_config вниз\nout['init_config'] = cfg;\n\n// 11) Прокинем NOTION_DATABASE_ID (из pick_db_by_name приоритетно)\nconst DB_ID = pickDbIdFromFlow();\nif (DB_ID){\n  out.NOTION_DATABASE_ID = DB_ID;\n  out.database_id        = DB_ID;\n  out.db_id              = DB_ID;\n}\n\n// Done\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        1264
      ],
      "id": "203099e7-b951-4126-9dff-d71d59ae4a75",
      "name": "normalize_for_notion",
      "executeOnce": false
    },
    {
      "parameters": {
        "content": "## Download image & link to image",
        "height": 256,
        "width": 1008
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        16,
        544
      ],
      "typeVersion": 1,
      "id": "558708ee-24bc-4e22-b111-261de8594cff",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## OpenAI classification and normalization for Notion",
        "height": 256,
        "width": 864,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1056,
        544
      ],
      "typeVersion": 1,
      "id": "533c8d3f-9047-4a6f-bf53-f3a7c98dc397",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "## Notion block \n",
        "height": 384,
        "width": 1056,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        848,
        1136
      ],
      "typeVersion": 1,
      "id": "c46ee72f-0b51-4ce7-a357-28883d02b1ab",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "jsCode": "/**\n * build_tg_message (safe)\n * Работает после pick_a_page (Append).\n * Для Update входных items 2 → берём последний; для Create 1.\n * Возвращает { text, chat_id, notion_url, notion_page_id, action, ... }.\n */\n\nfunction escMd(s) {\n  // лёгкий эскейп под Markdown/MarkdownV2\n  return String(s ?? '').replace(/([_*[\\]()~`>#+\\-=|{}.!\\\\])/g, '\\\\$1');\n}\nfunction safeItems(name, outIdx = 0) {\n  try { return $items(name, 0, outIdx) || []; } catch { return []; }\n}\n\n// 1) определим действие по количеству входных items\nconst inputPages = items.map(i => i.json).filter(p => p && p.object === 'page');\nconst page = inputPages[inputPages.length - 1] || null; // последний — нужный\nconst isUpdate = inputPages.length > 1 || safeItems(\"Update a page\").length > 0;\nconst isCreate = !isUpdate;\n\n// 2) chat_id из первого узла\nconst chat_id = (safeItems(\"extract_file_id\")[0]?.json?.chat_id) ?? null;\n\nif (!page) {\n  return [{ json: { text: \"⚠️ Пустой ответ от Notion.\", chat_id, notion_url: null, notion_page_id: null } }];\n}\n\nconst props = page.properties || {};\nconst title = props?.Title?.title?.[0]?.plain_text ?? 'Untitled';\nconst type  = props?.Type?.select?.name ?? 'Note';\nconst tagsArr = (props?.Tags?.multi_select ?? []).map(t => t?.name).filter(Boolean);\nconst tagsStr = tagsArr.join(', ');\nconst summary = (props?.Summary?.rich_text ?? []).map(r => r?.plain_text ?? '').join(' ').trim();\nconst srcUrl  = props?.[\"Source URL\"]?.url ?? null;\n\nconst d1 = props?.[\"event_DateStart\"]?.date?.start ?? null;\nconst d2 = props?.[\"event_DateEnd\"]?.date?.end ?? null;\nconst dateLine = (d1 || d2)\n  ? `🗓 ${escMd((d1 || '').slice(0, 10))}${d2 ? '–' + escMd(d2.slice(0, 10)) : ''}`\n  : null;\n\nconst notionUrl = page.url || null;\nconst action = isUpdate ? '✏️ Обновлено' : '🆕 Создано';\n\n// 3) текст для Telegram (Markdown)\nconst lines = [\n  `${action}: *${escMd(title)}*`,\n  `Тип: ${escMd(type)}${tagsStr ? ` | 🏷 ${escMd(tagsStr)}` : ''}`,\n  dateLine,\n  summary ? escMd(summary) : null,\n  srcUrl ? `🔗 ${srcUrl}` : null,\n  notionUrl ? `🗂 ${notionUrl}` : null,\n].filter(Boolean);\n\nreturn [{\n  json: {\n    text: lines.join('\\n'),\n    chat_id,\n    notion_url: notionUrl,\n    notion_page_id: page.id,\n    action: isUpdate ? 'update' : 'create',\n    tags: tagsArr,\n    type,\n    title\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        1248
      ],
      "id": "f6711eee-1234-4d15-9492-eea28bcd6eb1",
      "name": "build_tg_message"
    },
    {
      "parameters": {
        "jsCode": "// === build_create_payload (Simplified) ===\n// Create Notion page dynamically from simplified init_config + merged data.\n// Only includes fields that exist in the database schema.\n\n/************ Helpers ************/\nconst nonEmpty = v => (v!==null && v!==undefined && (typeof v!=='string' || v.trim()!=='') && (!Array.isArray(v) || v.length>0));\nconst toStr = v => (v==null ? '' : String(v));\nconst toNum = v => {\n  if (typeof v === 'number' && isFinite(v)) return v;\n  const n = Number(String(v).replace(/\\s+/g,'').replace(',', '.'));\n  return isFinite(n) ? n : undefined;\n};\nconst toISODate = v => {\n  if (!v) return undefined;\n  if (typeof v === 'string' && /^\\d{4}-\\d{2}-\\d{2}/.test(v)) return v.slice(0,10);\n  if (typeof v === 'string') {\n    const m = v.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/);\n    if (m) return `${m[3]}-${m[2]}-${m[1]}`;\n  }\n  const d = new Date(v);\n  return isNaN(+d) ? undefined : d.toISOString().slice(0,10);\n};\nconst arr = v => Array.isArray(v) ? v : (v==null ? [] : [v]);\nconst isObj = v => v && typeof v === 'object' && !Array.isArray(v);\n\nfunction inferType(name, value){\n  const s = String(name||'').toLowerCase();\n  if (s.includes('url') || /^https?:\\/\\//i.test(value||'')) return 'url';\n  if (s.endsWith('_email') || s === 'email') return 'email';\n  if (s.endsWith('_phone') || s === 'phone') return 'phone_number';\n  if (s.includes('date')) return 'date';\n  if (s.includes('price') || typeof value === 'number') return 'number';\n  if (s.includes('tags') || Array.isArray(value)) return 'multi_select';\n  if (s.includes('currency') || s.includes('status') || s.includes('type') || s.includes('category') || s.includes('lang') || s.includes('channel')) return 'select';\n  if (s.includes('screenshot') || s.endsWith('_file') || s.endsWith('_image')) return 'files';\n  if (s.includes('checkbox') || typeof value === 'boolean') return 'checkbox';\n  return 'rich_text';\n}\n\nfunction toMulti(val){\n  if (Array.isArray(val)) return val.filter(nonEmpty).map(toStr);\n  if (typeof val === 'string' && val.includes(',')) return val.split(',').map(s=>s.trim()).filter(nonEmpty);\n  return [toStr(val)];\n}\n\nfunction flatten(obj, out = {}) {\n  if (!isObj(obj)) return out;\n  for (const [k, v] of Object.entries(obj)) {\n    out[k] = v;\n    if (isObj(v) && ['data','payload','record','result','results','properties','output'].includes(k)) {\n      for (const [kk, vv] of Object.entries(v)) if (out[kk] === undefined) out[kk] = vv;\n    }\n  }\n  return out;\n}\n\n/************ Pickers ************/\nfunction pickInit(){\n  return $json.init_config\n      || ($items('init_config')?.[0]?.json)\n      || ($items('normalize_for_notion')?.[0]?.json?.init_config)\n      || null;\n}\n\nfunction mergedData(){\n  const all = $input.all() || [];\n  const sources = [\n    $items('normalize_for_notion')?.[0]?.json,\n    $json,\n    ...all.map(i => i.json),\n    $items('gd_output')?.[0]?.json,\n  ].filter(Boolean);\n  const m = {};\n  for (const s of sources) flatten(s, m);\n  return m;\n}\n\nfunction pickDbId(init){\n  const norm = $items('normalize_for_notion')?.[0]?.json;\n  if (norm?.NOTION_DATABASE_ID) return norm.NOTION_DATABASE_ID;\n  if (norm?.database_id)        return norm.database_id;\n  if (norm?.db_id)              return norm.db_id;\n\n  const fromPick = $items('pick_db_by_name')?.[0]?.json;\n  if (fromPick?.found_db_id) return fromPick.found_db_id;\n\n  if (init?.database_id) return init.database_id;\n\n  const fallbacks = [\n    $items('find_database_by_name')?.[0]?.json,\n    $items('get_db_by_name')?.[0]?.json,\n    $items('db_lookup')?.[0]?.json,\n    $json\n  ].filter(Boolean);\n  for (const j of fallbacks){\n    const id = j.found_db_id || j.database_id || j.db_id || j.id;\n    if (id) return id;\n  }\n  for (const it of ($input.all() || [])){\n    const j = it.json || {};\n    const id = j.found_db_id || j.database_id || j.db_id || j.id;\n    if (id) return id;\n  }\n  return null;\n}\n\nfunction pickImageUrls(r){\n  const candidates = [\n    r.gdrive_view_url,\n    r.ScreenshotUrl,\n    r.screenshot_url,\n    r.preview_url,\n    r.thumb_url,\n    r.image_url,\n    r.file_url\n  ].filter(nonEmpty);\n\n  if (nonEmpty(r.gdrive_file_id)){\n    const id = r.gdrive_file_id;\n    candidates.unshift(`https://drive.google.com/uc?export=view&id=${id}`);\n    candidates.unshift(`https://drive.google.com/thumbnail?id=${id}&sz=w2048`);\n  }\n  const uniq = [...new Set(candidates)];\n  const coverUrl = uniq.find(u => /thumbnail\\?id=|sz=w/i.test(u)) || uniq[0] || null;\n  const shotUrl  = uniq[0] || null;\n  return { coverUrl, shotUrl };\n}\n\n/************ Inputs ************/\nconst init = pickInit() || {};\nconst data = mergedData();\nconst DB_ID = pickDbId(init);\n\nif (!DB_ID) {\n  return [{ json: { _error: \"NO_DATABASE_ID\", _hint: \"Expected NOTION_DATABASE_ID from normalize_for_notion or found_db_id from pick_db_by_name\" } }];\n}\n\nconst { coverUrl, shotUrl } = pickImageUrls(data);\n\n// Get structure from simplified init_config\nconst dbStructure = init.DB_STRUCTURE || {};\nconst validFields = dbStructure.validFields || [];\nconst fieldTypes = dbStructure.fieldTypes || {};\nconst requiredFields = dbStructure.requiredFields || ['Title', 'Type'];\nconst autoFields = dbStructure.autoFields || {};\n\n/************ Build properties ************/\nconst P = {};\nconst fromConfig = new Set();\n\n// 1) Process all valid fields from data\nfor (const [fieldName, value] of Object.entries(data)) {\n  // Skip if field doesn't exist in DB schema\n  if (!validFields.includes(fieldName)) {\n    console.warn(`Skipping non-existent field: ${fieldName}`);\n    continue;\n  }\n  \n  fromConfig.add(fieldName);\n  \n  // Handle auto-generated fields\n  if (autoFields[fieldName] && typeof autoFields[fieldName] === 'function') {\n    const autoValue = autoFields[fieldName]();\n    if (fieldName === 'Captured at') {\n      P[fieldName] = { date: { start: autoValue } };\n    } else if (fieldName === 'Channel') {\n      P[fieldName] = { select: { name: autoValue } };\n    }\n    continue;\n  }\n  \n  const fieldType = fieldTypes[fieldName] || inferType(fieldName, value);\n  \n  // Skip empty values except for specific types\n  if (!nonEmpty(value) && !['files','date','checkbox'].includes(fieldType)) continue;\n  \n  switch (fieldType) {\n    case 'title':\n      P[fieldName] = { title: [{ text: { content: toStr(value) } }] };\n      break;\n    case 'select':\n      P[fieldName] = { select: nonEmpty(value) ? { name: toStr(value) } : null };\n      break;\n    case 'multi_select':\n      P[fieldName] = { multi_select: toMulti(value).map(v => ({ name: v })) };\n      break;\n    case 'number': {\n      const n = toNum(value);\n      if (n !== undefined) P[fieldName] = { number: n };\n      break;\n    }\n    case 'date': {\n      if (value && typeof value === 'object' && ('start' in value || 'end' in value)) {\n        const s = toISODate(value.start); const e = toISODate(value.end);\n        if (s || e) P[fieldName] = { date: { start: s || e, end: e || null } };\n      } else {\n        const s = toISODate(value);\n        if (s) P[fieldName] = { date: { start: s } };\n      }\n      break;\n    }\n    case 'url':\n      if (nonEmpty(value)) P[fieldName] = { url: toStr(value) };\n      break;\n    case 'email':\n      if (nonEmpty(value)) P[fieldName] = { email: toStr(value) };\n      break;\n    case 'phone_number':\n      if (nonEmpty(value)) P[fieldName] = { phone_number: toStr(value) };\n      break;\n    case 'files': {\n      const url = (fieldName === 'Screenshot') ? (shotUrl || toStr(value)) : (toStr(value) || shotUrl);\n      if (nonEmpty(url)) P[fieldName] = { files: [{ name: data.ScreenShotFile || 'file', external: { url } }] };\n      break;\n    }\n    case 'checkbox':\n      P[fieldName] = { checkbox: !!value };\n      break;\n    default:\n      if (nonEmpty(value)) P[fieldName] = { rich_text: [{ text: { content: toStr(value) } }] };\n  }\n}\n\n// 2) Ensure required fields are present\nfor (const requiredField of requiredFields) {\n  if (!P[requiredField]) {\n    if (requiredField === 'Title') {\n      P[requiredField] = { title: [{ text: { content: 'Untitled' } }] };\n    } else if (requiredField === 'Type') {\n      P[requiredField] = { select: { name: 'Note' } };\n    }\n  }\n}\n\n// 3) Ensure Captured at is set\nif (!P['Captured at']) {\n  const today = new Date().toISOString().slice(0,10);\n  P['Captured at'] = { date: { start: today } };\n}\n\n// 4) Add Screenshot if not already set and we have a URL\nif (!P['Screenshot'] && nonEmpty(shotUrl)) {\n  P['Screenshot'] = { files: [{ name: data.ScreenShotFile || 'screenshot.jpg', external: { url: shotUrl } }] };\n}\n\n/************ Return ************/\nreturn [{\n  json: {\n    method: \"POST\",\n    url: \"https://api.notion.com/v1/pages\",\n    body: {\n      parent: { database_id: DB_ID },\n      properties: P,\n      ...(nonEmpty(coverUrl) ? { cover: { external: { url: coverUrl } } } : {})\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1312,
        1424
      ],
      "id": "e1dba9d3-072a-414d-9a5f-b27ec0e23f0b",
      "name": "build_create_payload"
    },
    {
      "parameters": {
        "method": "={{$json.method}}",
        "url": "={{$json.url}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Notion-Version",
              "value": "2022-06-28"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1536,
        1248
      ],
      "id": "a66786df-e692-4edf-9b44-b5719f655b7a",
      "name": "notion_create",
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLsgLtaE3BqffWDF",
          "name": "NotionRaw"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === build_update_payload (Simplified) ===\n// Update Notion page dynamically from simplified init_config + merged data.\n// Only includes fields that exist in the database schema.\n\n/************ Helpers ************/\nconst nonEmpty = v => (v!==null && v!==undefined && (typeof v!=='string' || v.trim()!=='') && (!Array.isArray(v) || v.length>0));\nconst toStr = v => (v==null ? '' : String(v));\nconst toNum = v => {\n  if (typeof v === 'number' && isFinite(v)) return v;\n  const n = Number(String(v).replace(/\\s+/g,'').replace(',', '.'));\n  return isFinite(n) ? n : undefined;\n};\nconst toISODate = v => {\n  if (!v) return undefined;\n  if (typeof v === 'string' && /^\\d{4}-\\d{2}-\\d{2}/.test(v)) return v.slice(0,10);\n  if (typeof v === 'string') {\n    const m = v.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/);\n    if (m) return `${m[3]}-${m[2]}-${m[1]}`;\n  }\n  const d = new Date(v);\n  return isNaN(+d) ? undefined : d.toISOString().slice(0,10);\n};\nconst arr = v => Array.isArray(v) ? v : (v==null ? [] : [v]);\nconst isObj = v => v && typeof v === 'object' && !Array.isArray(v);\n\nfunction inferType(name, value){\n  const s = String(name||'').toLowerCase();\n  if (s.includes('url') || /^https?:\\/\\//i.test(value||'')) return 'url';\n  if (s.endsWith('_email') || s === 'email') return 'email';\n  if (s.endsWith('_phone') || s === 'phone') return 'phone_number';\n  if (s.includes('date')) return 'date';\n  if (s.includes('price') || typeof value === 'number') return 'number';\n  if (s.includes('tags') || Array.isArray(value)) return 'multi_select';\n  if (s.includes('currency') || s.includes('status') || s.includes('type') || s.includes('category') || s.includes('lang') || s.includes('channel')) return 'select';\n  if (s.includes('screenshot') || s.endsWith('_file') || s.endsWith('_image')) return 'files';\n  if (s.includes('checkbox') || typeof value === 'boolean') return 'checkbox';\n  return 'rich_text';\n}\n\nfunction toMulti(val){\n  if (Array.isArray(val)) return val.filter(nonEmpty).map(toStr);\n  if (typeof val === 'string' && val.includes(',')) return val.split(',').map(s=>s.trim()).filter(nonEmpty);\n  return [toStr(val)];\n}\n\nfunction flatten(obj, out = {}) {\n  if (!isObj(obj)) return out;\n  for (const [k, v] of Object.entries(obj)) {\n    out[k] = v;\n    if (isObj(v) && ['data','payload','record','result','results','properties','output'].includes(k)) {\n      for (const [kk, vv] of Object.entries(v)) if (out[kk] === undefined) out[kk] = vv;\n    }\n  }\n  return out;\n}\n\n/************ Pickers ************/\nfunction pickInit(){\n  return $json.init_config\n      || ($items('init_config')?.[0]?.json)\n      || ($items('normalize_for_notion')?.[0]?.json?.init_config)\n      || null;\n}\n\nfunction mergedData(){\n  const all = $input.all() || [];\n  const sources = [\n    $items('normalize_for_notion')?.[0]?.json,\n    $json,\n    ...all.map(i => i.json),\n    $items('gd_output')?.[0]?.json,\n  ].filter(Boolean);\n  const m = {};\n  for (const s of sources) flatten(s, m);\n  return m;\n}\n\nfunction pickImageUrls(r){\n  const candidates = [\n    r.gdrive_view_url,\n    r.ScreenshotUrl,\n    r.screenshot_url,\n    r.preview_url,\n    r.thumb_url,\n    r.image_url,\n    r.file_url\n  ].filter(nonEmpty);\n\n  if (nonEmpty(r.gdrive_file_id)){\n    const id = r.gdrive_file_id;\n    candidates.unshift(`https://drive.google.com/uc?export=view&id=${id}`);\n    candidates.unshift(`https://drive.google.com/thumbnail?id=${id}&sz=w2048`);\n  }\n  const uniq = [...new Set(candidates)];\n  const coverUrl = uniq.find(u => /thumbnail\\?id=|sz=w/i.test(u)) || uniq[0] || null;\n  const shotUrl  = uniq[0] || null;\n  return { coverUrl, shotUrl };\n}\n\n/* pageId finder — берём из входов */\nfunction pickPageId(){\n  if ($json?.id && $json?.url) return $json.id;\n  try { const a = $input.all().find(i=>i.json?.id && i.json?.url); if(a) return a.json.id; } catch {}\n  try { return $items(\"Check for Many\")?.[0]?.json?.id; } catch {}\n  return null;\n}\n\n/************ Inputs ************/\nconst init = pickInit() || {};\nconst data = mergedData();\nconst { coverUrl, shotUrl } = pickImageUrls(data);\nconst pageId = pickPageId();\n\nif (!pageId) {\n  return [{ json: { _error: \"NO_PAGE_ID\", _hint: \"Upstream must pass Notion page id (e.g., from search/merge node)\" } }];\n}\n\n// Get structure from simplified init_config\nconst dbStructure = init.DB_STRUCTURE || {};\nconst validFields = dbStructure.validFields || [];\nconst fieldTypes = dbStructure.fieldTypes || {};\nconst readOnlyFields = dbStructure.readOnlyFields || ['UID', 'Captured at'];\n\n/************ Build properties ************/\nconst P = {};\nconst fromConfig = new Set();\n\n// 1) Only process fields that exist in the database schema\nfor (const [fieldName, value] of Object.entries(data)) {\n  // Skip if field doesn't exist in DB schema\n  if (!validFields.includes(fieldName)) {\n    console.warn(`Skipping non-existent field: ${fieldName}`);\n    continue;\n  }\n  \n  // Skip read-only fields for updates\n  if (readOnlyFields.includes(fieldName)) {\n    continue;\n  }\n  \n  fromConfig.add(fieldName);\n  \n  const fieldType = fieldTypes[fieldName] || inferType(fieldName, value);\n  \n  // Skip empty values except for specific types\n  if (!nonEmpty(value) && !['files','date','checkbox'].includes(fieldType)) continue;\n  \n  switch (fieldType) {\n    case 'title':\n      P[fieldName] = { title: [{ text: { content: toStr(value) } }] };\n      break;\n    case 'select':\n      P[fieldName] = { select: nonEmpty(value) ? { name: toStr(value) } : null };\n      break;\n    case 'multi_select':\n      P[fieldName] = { multi_select: toMulti(value).map(v => ({ name: v })) };\n      break;\n    case 'number': {\n      const n = toNum(value);\n      if (n !== undefined) P[fieldName] = { number: n };\n      break;\n    }\n    case 'date': {\n      if (value && typeof value === 'object' && ('start' in value || 'end' in value)) {\n        const s = toISODate(value.start); const e = toISODate(value.end);\n        if (s || e) P[fieldName] = { date: { start: s || e, end: e || null } };\n      } else {\n        const s = toISODate(value);\n        if (s) P[fieldName] = { date: { start: s } };\n      }\n      break;\n    }\n    case 'url':\n      if (nonEmpty(value)) P[fieldName] = { url: toStr(value) };\n      break;\n    case 'email':\n      if (nonEmpty(value)) P[fieldName] = { email: toStr(value) };\n      break;\n    case 'phone_number':\n      if (nonEmpty(value)) P[fieldName] = { phone_number: toStr(value) };\n      break;\n    case 'files': {\n      const url = (fieldName === 'Screenshot') ? (shotUrl || toStr(value)) : (toStr(value) || shotUrl);\n      if (nonEmpty(url)) P[fieldName] = { files: [{ name: data.ScreenShotFile || 'file', external: { url } }] };\n      break;\n    }\n    case 'checkbox':\n      P[fieldName] = { checkbox: !!value };\n      break;\n    default:\n      if (nonEmpty(value)) P[fieldName] = { rich_text: [{ text: { content: toStr(value) } }] };\n  }\n}\n\n/************ Return ************/\nconst body = {\n  properties: P,\n  // cover добавляем только если есть НОВЫЙ url\n  ...(nonEmpty(coverUrl) ? { cover: { external: { url: coverUrl } } } : {})\n};\n\nreturn [{\n  json: {\n    method: \"PATCH\",\n    url: `https://api.notion.com/v1/pages/${pageId}`,\n    body\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1312,
        1248
      ],
      "id": "afc10835-9a1a-455d-af72-65a798e355e4",
      "name": "build_update_payload"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram file URL from getFile response.\n * Требуется ENV: TELEGRAM_BOT_TOKEN\n * Вход: { result: { file_path: \"photos/file_1.jpg\" }, ... }\n * Выход: добавляет tg_file_url / screenshot_url и не теряет остальные поля.\n */\nconst path  = $json?.result?.file_path || $json?.file_path || null;\n//const token =$('extract_file_id').first().json.token;\nconst token = $node['extract_file_id'].json.token;\nif (!path) {\n  return [{\n    json: { ...$json, tg_file_url: null, _error: 'No file_path in input. Connect after getFile.' }\n  }];\n}\nif (!token) {\n  return [{\n    json: { ...$json, tg_file_url: null, _error: 'Missing $env.TELEGRAM_BOT_TOKEN' }\n  }];\n}\n\nconst tg_file_url = `https://api.telegram.org/file/bot${token}/${path}`;\nconst fileName = path.split('/').pop() || 'file';\nconst fileExt  = (fileName.split('.').pop() || '').toLowerCase() || 'jpg';\n\nreturn [{\n  json: {\n    ...$json,\n    tg_file_url,\n    screenshot_url: tg_file_url,  // удобно дальше отдавать в Notion/AI\n    file_name: fileName,\n    file_ext: fileExt,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        608
      ],
      "id": "70c3a288-01d8-4b7a-92d8-66f48f5ad2f0",
      "name": "build_tgURL"
    },
    {
      "parameters": {
        "type": "SHA256",
        "binaryData": true,
        "binaryPropertyName": "screenshot",
        "dataPropertyName": "ImageUID"
      },
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        880,
        608
      ],
      "id": "ebf00231-fc06-46bf-8ceb-5baf6b14c21a",
      "name": "Crypto"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "Yxs70uuQ2IMHaXP9",
          "mode": "list",
          "cachedResultName": "GDrive_upload"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {}
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        480,
        1264
      ],
      "id": "d0f30ead-105d-43c1-a2d4-2da579df5a4d",
      "name": "call_gdrive_flow"
    },
    {
      "parameters": {
        "content": "## GDRIVE",
        "height": 384,
        "width": 800,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        16,
        1136
      ],
      "typeVersion": 1,
      "id": "289bff48-2077-42a7-a924-e54e3535be9a",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "jsCode": "// Строим вход для GDrive-потока из normalize_for_notion\nconst r = $json || {};\nconst parentId  = r.rootFolderId;                  // ID корневой папки на My Drive\nconst folderName= r.Type || 'Other';               // имя подпапки\nconst fileUrl   = r.screenshot_url || r.tg_file_url;// исходная ссылка на картинку\nlet   fileName  = r.file_name || 'screenshot';\n\nif (!parentId)  throw new Error('normalize_for_notion: missing rootFolderId');\nif (!folderName)throw new Error('normalize_for_notion: missing Type');\nif (!fileUrl)   throw new Error('normalize_for_notion: missing ScreenshotUrl/tg_file_url');\n\nif (!/\\.[a-z0-9]+$/i.test(fileName)) fileName += '.jpg';\n\nreturn [{ json: { parentId, folderName, fileUrl, fileName, _norm: r } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        272,
        1264
      ],
      "id": "45fd1231-4980-4314-b7af-504b853eef73",
      "name": "gd_input"
    },
    {
      "parameters": {
        "jsCode": "// Берём нормализованные поля из узла gd_input_from_norm\nconst norm = ($items('gd_input')[0]?.json?._norm) \n          || ($items('normalize_for_notion')[0]?.json) \n          || {};\n\n// Берём результат саб-флоу (текущий item)\nconst { fileId, id, driveViewUrl, driveDirectUrl } = $json;\n\n// В саб-флоу лучше возвращать fileId. Но на всякий случай поддержим и id.\nconst gId = fileId || id || null;\n\nif (!gId) {\n  // Не роняем пайплайн — просто прокинем warning и исходный norm\n  return [{\n    json: {\n      ...norm,\n      _warning: 'GDrive: no file id from subflow',\n      ScreenshotUrl: norm.ScreenshotUrl ?? null,\n    }\n  }];\n}\n\n// Мержим назад: ставим ссылку с Drive как основную картинку,\n// пробрасываем id и view-url\nreturn [{\n  json: {\n    ...norm,\n    ScreenshotUrl: driveDirectUrl ?? norm.ScreenshotUrl ?? null,\n    gdrive_file_id: gId,\n    gdrive_view_url: driveViewUrl ?? null,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        1264
      ],
      "id": "af93cf10-b918-4ad9-bde8-4739c93228d7",
      "name": "gd_output"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Simplified init_config - Single source of truth for field definitions\n * \n * TO ADD A NEW FIELD:\n * 1. Add it to the FIELDS array below\n * 2. Add prompt description\n * 3. Everything else is automatic\n */\n\nconst FIELDS = [\n  // === CORE FIELDS (always present) ===\n  {\n    name: \"Title\",\n    type: \"title\",\n    prompt: \"Short human-readable title from the main on-image heading; else concise summary (≤80 chars).\",\n    required: true,\n    alwaysShow: true\n  },\n  {\n    name: \"Type\", \n    type: \"select\",\n    options: [\"Note\", \"Product\", \"Contact\", \"Event\"],\n    prompt: \"Classify the screenshot into exactly one of: Product, Contact, Event, Note.\",\n    required: true,\n    alwaysShow: true\n  },\n  {\n    name: \"Category\",\n    type: \"select\", \n    options: [],\n    prompt: \"Optional subcategory (e.g., electronics, restaurant, conference). Null if unsure.\",\n    alwaysShow: true\n  },\n  {\n    name: \"Tags\",\n    type: \"multi_select\",\n    prompt: \"3–7 keywords; deduplicate; keep source language; no # and no emojis.\",\n    alwaysShow: true\n  },\n  {\n    name: \"Summary\",\n    type: \"rich_text\",\n    prompt: \"2–5 sentences summary using only visible info from the screenshot.\",\n    alwaysShow: true\n  },\n  {\n    name: \"Key facts\",\n    type: \"rich_text\", \n    prompt: \"Markdown bullets with actionable facts from the screenshot only (one fact per bullet).\",\n    alwaysShow: true\n  },\n  {\n    name: \"Source URL\",\n    type: \"url\",\n    prompt: \"Public source link if explicitly visible/copyable on screenshot; else null.\",\n    alwaysShow: true\n  },\n  {\n    name: \"Screenshot\",\n    type: \"files\",\n    prompt: \"Leave null — pipeline sets the public URL later.\",\n    alwaysShow: true,\n    autoGenerated: true\n  },\n  {\n    name: \"Captured at\",\n    type: \"date\",\n    prompt: \"Auto-generated timestamp when item was captured.\",\n    alwaysShow: true,\n    autoGenerated: true,\n    readOnly: true\n  },\n  {\n    name: \"Status\",\n    type: \"select\",\n    options: [\"New\", \"Processed\"],\n    prompt: \"Processing status of the item.\",\n    alwaysShow: true\n  },\n  {\n    name: \"Confidence\",\n    type: \"number\",\n    prompt: \"Self-estimated confidence 0..1 (float). Lower it if any required field is missing/uncertain.\",\n    alwaysShow: true\n  },\n  {\n    name: \"Lang\",\n    type: \"select\",\n    options: [\"en\", \"ru\", \"uk\", \"auto\"],\n    prompt: \"Dominant OCR language code of the screenshot text. Do not translate output.\",\n    alwaysShow: true\n  },\n  {\n    name: \"Channel\",\n    type: \"select\",\n    options: [\"Telegram Bot\"],\n    prompt: \"Fixed: 'Telegram Bot' unless specified otherwise.\",\n    alwaysShow: true,\n    autoGenerated: true\n  },\n  {\n    name: \"UID\",\n    type: \"rich_text\",\n    prompt: \"Unique identifier for the item.\",\n    alwaysShow: true,\n    readOnly: true,\n    autoGenerated: true\n  },\n\n  // === PRODUCT FIELDS (only when Type = \"Product\") ===\n  {\n    name: \"product_Price\",\n    type: \"number\",\n    prompt: \"Numeric price if visible; else null.\",\n    showWhen: \"Type === 'Product'\"\n  },\n  {\n    name: \"product_Currency\", \n    type: \"select\",\n    options: [\"USD\", \"EUR\", \"UAH\"],\n    prompt: \"ISO currency inferred from symbol/text; else null.\",\n    showWhen: \"Type === 'Product'\"\n  },\n  {\n    name: \"product_Vendor\",\n    type: \"rich_text\",\n    prompt: \"Store or brand name if present; else null.\",\n    showWhen: \"Type === 'Product'\"\n  },\n  {\n    name: \"product_StoreURL\",\n    type: \"url\", \n    prompt: \"Product/app page if visible; else null.\",\n    showWhen: \"Type === 'Product'\"\n  },\n\n  // === CONTACT FIELDS (only when Type = \"Contact\") ===\n  {\n    name: \"contact_Email\",\n    type: \"email\",\n    prompt: \"Email if shown; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_Phone\",\n    type: \"phone_number\",\n    prompt: \"Phone (international format if possible) or raw digits; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_Address\",\n    type: \"rich_text\",\n    prompt: \"Postal address lines if shown; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_mapURL\",\n    type: \"url\",\n    prompt: \"Map link if visible; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_Lat\",\n    type: \"number\",\n    prompt: \"Latitude if explicitly shown; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_Lng\", \n    type: \"number\",\n    prompt: \"Longitude if explicitly shown; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_LinkedIn\",\n    type: \"url\",\n    prompt: \"LinkedIn URL/handle if visible; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_Telegram\",\n    type: \"url\",\n    prompt: \"Telegram @handle or link; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n  {\n    name: \"contact_Instagram\",\n    type: \"url\",\n    prompt: \"Instagram @handle or link; else null.\",\n    showWhen: \"Type === 'Contact'\"\n  },\n\n  // === EVENT FIELDS (only when Type = \"Event\") ===\n  {\n    name: \"event_Date\",\n    type: \"date\",\n    prompt: \"Object: { Start: ISO8601, End: ISO8601|null } parsed from the screenshot.\",\n    showWhen: \"Type === 'Event'\"\n  },\n  {\n    name: \"event_DateStart\",\n    type: \"date\", \n    prompt: \"Event start date if present; else null.\",\n    showWhen: \"Type === 'Event'\"\n  },\n  {\n    name: \"event_DateEnd\",\n    type: \"date\",\n    prompt: \"Event end date if present; else null.\",\n    showWhen: \"Type === 'Event'\"\n  },\n  {\n    name: \"event_Email\",\n    type: \"email\",\n    prompt: \"If present; else null.\",\n    showWhen: \"Type === 'Event'\"\n  },\n  {\n    name: \"event_Phone\",\n    type: \"phone_number\",\n    prompt: \"If present; else null.\",\n    showWhen: \"Type === 'Event'\"\n  },\n  {\n    name: \"event_Adddress\",\n    type: \"rich_text\",\n    prompt: \"If present; else null.\",\n    showWhen: \"Type === 'Event'\"\n  },\n  {\n    name: \"event_AddressURL\",\n    type: \"url\",\n    prompt: \"If present; else null.\",\n    showWhen: \"Type === 'Event'\"\n  },\n  {\n    name: \"event_Price\",\n    type: \"number\",\n    prompt: \"Numeric value if shown; else null.\",\n    showWhen: \"Type === 'Event'\"\n  },\n\n  // === NOTES FIELDS (only when Type = \"Note\") ===\n  {\n    name: \"notes_Topic\",\n    type: \"rich_text\",\n    prompt: \"Single-word/short topic if inferable (e.g., 'idea','todo'); else null.\",\n    showWhen: \"Type === 'Note'\"\n  },\n  {\n    name: \"notes_Source\",\n    type: \"rich_text\",\n    prompt: \"If screenshot references a source (doc/app/site); else null.\",\n    showWhen: \"Type === 'Note'\"\n  },\n\n  // === TECHNICAL FIELDS ===\n  \n];\n\n// === WORKFLOW SETTINGS ===\nconst WORKFLOW_SETTINGS = {\n  // Database settings\n  NOTION_DB_NAME: \"ScreenNotes\",\n  NOTION_PARENT_PAGE_ID: \"283727b4bd4b8084a082d9aa2ce5e9d3\",\n  NOTION_VERSION: \"2022-06-28\",\n  STRICT_DB_NAME_MATCH: true,\n  \n  // Telegram settings  \n  TELEGRAM_BOT_TOKEN: \"8349012441:AAF0_PdT0ltnkii1uX9_L9mm0-o20dZuMuo\",\n  TELEGRAM_PARSE_MODE: \"MarkdownV2\",\n  \n  // Google Drive settings\n  DRIVE_PARENT_ID: \"1GXUsibJx5Ny7r05F9CWGeSuUCrIbH3rU\",\n  DRIVE_LINK_KIND: \"view\",\n  DRIVE_SHARE_ROLE: \"reader\", \n  DRIVE_SHARE_TYPE: \"anyone\",\n  // SerpApi Configuration\n  SERPAPI_API_KEY: \"a11842f7facf074f2352c68ee6fbb5b9a8ca4744cb53821cabee9620b6e2c3fb\",\n  ENABLE_ENRICHMENT: true,\n  ENRICHMENT_TIMEOUT: 15000,\n  ENRICHMENT_MAX_RETRIES: 2,\n  \n  // Contact Maps Enrichment\n  CONTACT_MAPS_ENRICHMENT: {\n    enabled: true,\n    triggers: [\"contact_Address\", \"Title\"],\n    generateMapUrl: true,\n    validateAddress: true\n  },\n  \n  // Event URL Enrichment\n  EVENT_URL_ENRICHMENT: {\n    enabled: true,\n    triggers: [\"event_Adddress\", \"Title\", \"event_DateStart\"],\n    findEventUrls: true,\n    validateAddress: true,\n    eventDomains: [\n      \"eventbrite.com\",\n      \"ticketmaster.com\", \n      \"meetup.com\",\n      \"facebook.com/events\"\n    ]\n  },\n  \n  // Default settings\n  DEFAULT_LANG: \"en\",\n  CREATE_DB_IF_MISSING: true,\n  NOTION_SEARCH_LIMIT: 10,\n  MAX_FILE_MB: 40,\n  LOG_LEVEL: \"info\"\n};\n\n// === AUTO-GENERATE CONFIGURATIONS ===\n\n// 1. Generate Notion DB Properties for database creation\nfunction generateNotionProperties(fields) {\n  const properties = {};\n  fields.forEach(field => {\n    const baseProperty = { [field.type]: {} };\n    \n    if (field.options && field.options.length > 0) {\n      baseProperty[field.type].options = field.options.map(opt => ({ name: opt }));\n    }\n    \n    if (field.type === 'number') {\n      baseProperty[field.type].format = 'number';\n    }\n    \n    properties[field.name] = baseProperty;\n  });\n  return properties;\n}\n\n// 2. Generate field prompts for AI\nfunction generateFieldPrompts(fields) {\n  const prompts = {};\n  fields.forEach(field => {\n    if (field.prompt) {\n      prompts[field.name] = field.prompt;\n    }\n  });\n  return prompts;\n}\n\n// 3. Generate DB structure for validation\nfunction generateDBStructure(fields) {\n  return {\n    validFields: fields.map(f => f.name),\n    fieldTypes: Object.fromEntries(fields.map(f => [f.name, f.type])),\n    requiredFields: fields.filter(f => f.required).map(f => f.name),\n    readOnlyFields: fields.filter(f => f.readOnly).map(f => f.name),\n    autoFields: {\n      \"Captured at\": () => new Date().toISOString().slice(0, 10),\n      \"Channel\": () => \"Telegram Bot\"\n    },\n    conditionalFields: fields.filter(f => f.showWhen).map(f => ({\n      name: f.name,\n      condition: f.showWhen\n    }))\n  };\n}\n\n// 4. Generate type-specific field groups\nfunction generateTypeGroups(fields) {\n  const groups = {\n    Product: {},\n    Contact: {},\n    Event: {},\n    Note: {}\n  };\n  \n  fields.forEach(field => {\n    if (field.showWhen) {\n      const type = field.showWhen.replace(\"Type === '\", \"\").replace(\"'\", \"\");\n      if (groups[type]) {\n        groups[type][field.name] = { prompt: field.prompt };\n      }\n    }\n  });\n  \n  return groups;\n}\n\n// === BUILD FINAL CONFIGURATION ===\nconst config = {\n  // Workflow settings\n  ...WORKFLOW_SETTINGS,\n  \n  // Generated configurations\n  NOTION_DB_PROPERTIES: generateNotionProperties(FIELDS),\n  DB_STRUCTURE: generateDBStructure(FIELDS),\n  FIELDS: generateFieldPrompts(FIELDS),\n  PER_TYPE: generateTypeGroups(FIELDS),\n  \n  // AI prompt configuration\n  TYPE_OPTIONS: {\n    Type: {\n      select: { options: FIELDS.find(f => f.name === \"Type\").options.map(name => ({ name })) },\n      prompt: FIELDS.find(f => f.name === \"Type\").prompt\n    }\n  },\n  \n  // Output schema for AI\n  OUTPUT_SCHEMA: {\n    base: Object.fromEntries(\n      FIELDS.filter(f => f.alwaysShow).map(f => [\n        f.name, \n        f.type === 'multi_select' ? 'string[]' : \n        f.type === 'number' ? 'number' : \n        f.type === 'checkbox' ? 'boolean' : 'string|null'\n      ])\n    )\n  },\n  \n  // Policy\n  POLICY: {\n    language: \"Output language = dominant OCR language; never translate.\",\n    missing: \"If a value is not on the screenshot, set it to null and decrease confidence.\",\n    scriptsGuard: \"Do not output ko/ja/zh unless those scripts appear in the screenshot.\"\n  }\n};\n\nreturn [{ json: config }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32,
        80
      ],
      "id": "7ba7cb68-f453-47f3-9bc5-3a0b6d619aac",
      "name": "init_config"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.notion.com/v1/databases",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Notion-Version",
              "value": "={{$json.meta.notionVersion}}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{$json.body}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        256,
        368
      ],
      "id": "f94adce7-c883-45c7-8b08-d79644ff31e6",
      "name": "notion_create_db",
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLsgLtaE3BqffWDF",
          "name": "NotionRaw"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * build_notion_create_payload\n * Builds a Notion /v1/databases create body entirely from init_config.\n * Fails early with clear messages if something is missing.\n *\n * Inputs:\n *  - $items('init_config')[0].json:\n *      NOTION_PARENT_PAGE_ID (string, 32-hex or with dashes)\n *      NOTION_DB_NAME        (string)\n *      NOTION_DB_PROPERTIES  (object)  // full schema\n *      NOTION_VERSION        (string)  // e.g. \"2022-06-28\"\n *\n * Output:\n *  - json: { body, meta } where:\n *      body = ready-to-send request body for POST /v1/databases\n *      meta = { notionVersion, name }\n */\n\nfunction normId(id) {\n  if (!id) return null;\n  const clean = String(id).replace(/-/g, '');\n  return /^[a-f0-9]{32}$/i.test(clean) ? clean : null;\n}\n\nconst ini = $items('init_config')[0]?.json || {};\nconst parentPageRaw = ini.NOTION_PARENT_PAGE_ID;\nconst parentPageId  = normId(parentPageRaw);\n\nif (!parentPageId) {\n  throw new Error(\"init_config: NOTION_PARENT_PAGE_ID is missing or invalid. Open your parent page and copy 32-hex ID from its URL.\");\n}\n\nconst dbName = (ini.NOTION_DB_NAME || '').trim();\nif (!dbName) {\n  throw new Error(\"init_config: NOTION_DB_NAME is required.\");\n}\n\nconst properties = ini.NOTION_DB_PROPERTIES;\nif (!properties || typeof properties !== 'object' || Array.isArray(properties)) {\n  throw new Error(\"init_config: NOTION_DB_PROPERTIES must be an object with Notion property definitions.\");\n}\n\n// Optional sanity: ensure Title exists\nif (!properties.Title || !('title' in properties.Title)) {\n  throw new Error('init_config: NOTION_DB_PROPERTIES must include a \"Title\" property of type { \"title\": {} }.');\n}\n\n// Build create body\nconst body = {\n  parent: { type: \"page_id\", page_id: parentPageId },\n  title: [{ type: \"text\", text: { content: dbName } }],\n  properties\n};\n\n// Pass Notion-Version via meta (for HTTP node headers)\nconst notionVersion = ini.NOTION_VERSION || \"2022-06-28\";\n\nreturn [{\n  json: {\n    body,\n    meta: { notionVersion, name: dbName, parentPageId }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        368
      ],
      "id": "a8e40629-53b0-406b-ba8f-3e29ef5c34cc",
      "name": "build_db_create payload"
    },
    {
      "parameters": {
        "jsCode": "/**\n * pick_db_by_name\n * Selects a Notion database from /v1/search results using strict rules.\n *\n * Inputs:\n *  - $items('init_config')[0].json:\n *      NOTION_DB_NAME            (string)   // target DB name, e.g. \"ScreenSave 3\"\n *      NOTION_PARENT_PAGE_ID     (string)   // optional parent page to match against\n *      STRICT_DB_NAME_MATCH      (boolean)  // default: true (exact match)\n *      REQUIRE_PARENT_MATCH      (boolean)  // default: false (also check parent)\n *      ALLOW_CONTAINS_FALLBACK   (boolean)  // default: false (fallback to 'includes')\n *\n *  - $json.results               (array)    // raw response from POST /v1/search\n *\n * Output (one item):\n *  - json: {\n *      db_exist,                   // <-- ADDED: boolean\n *      found_db_id,\n *      found_db_url,\n *      found_title,\n *      found_parent_page_id,\n *      resolved_as,                // 'exact' | 'contains' | null\n *      candidates_seen: [{ id, title, parent_page_id, url }],\n *      inspected_count,\n *      // convenience/debugging:\n *      requested_name,\n *      require_parent_match,\n *      matched_parent,             // boolean | null (null if not applicable)\n *      note                        // optional hint when not found\n *    }\n */\n\nfunction normId(x) {\n  if (!x) return null;\n  return String(x).replace(/-/g, '').toLowerCase();\n}\nfunction titleOf(db) {\n  const t = db?.title?.[0]?.plain_text;\n  return (t ? String(t) : '').trim();\n}\nfunction parentPageOf(db) {\n  if (db?.parent?.type === 'page_id') return db.parent.page_id || null;\n  return null;\n}\n\nconst ini = $items('init_config')[0]?.json ?? {};\nconst wantName = (ini.NOTION_DB_NAME || '').trim();\nconst wantNameLC = wantName.toLowerCase();\nconst strict = ini.STRICT_DB_NAME_MATCH !== false;     // default true\nconst requireParent = !!ini.REQUIRE_PARENT_MATCH;      // default false\nconst allowContains = !!ini.ALLOW_CONTAINS_FALLBACK;   // default false\nconst wantParentNorm = normId(ini.NOTION_PARENT_PAGE_ID);\n\nconst results = Array.isArray($json.results) ? $json.results : [];\nconst onlyDB = results.filter(r => r && r.object === 'database');\n\n// Lightweight view of candidates for logs/diagnostics\nconst candidates_seen = onlyDB.map(db => ({\n  id: db.id,\n  title: titleOf(db),\n  parent_page_id: parentPageOf(db),\n  url: db.url || null\n}));\n\nfunction parentMatches(db) {\n  if (!requireParent) return true;\n  const p = parentPageOf(db);\n  return normId(p) === wantParentNorm;\n}\n\n// 1) Exact match first (recommended)\nlet chosen = null;\nif (strict) {\n  chosen = onlyDB.find(db =>\n    titleOf(db).toLowerCase() === wantNameLC && parentMatches(db)\n  );\n}\n\n// 2) Optional contains fallback (either explicitly allowed or if strict disabled)\nlet resolved_as = null;\nif (chosen) {\n  resolved_as = 'exact';\n} else if (allowContains || !strict) {\n  chosen = onlyDB.find(db =>\n    titleOf(db).toLowerCase().includes(wantNameLC) && parentMatches(db)\n  );\n  if (chosen) resolved_as = 'contains';\n}\n\n// Derive booleans / hints\nconst db_exists = !!chosen;\nconst matched_parent = db_exists\n  ? (requireParent ? normId(parentPageOf(chosen)) === wantParentNorm : null)\n  : null;\n\nlet note = undefined;\nif (!db_exists) {\n  if (!wantName) {\n    note = 'NOTION_DB_NAME is empty; cannot select a database.';\n  } else if (requireParent && wantParentNorm && onlyDB.some(db => titleOf(db).toLowerCase() === wantNameLC)) {\n    note = 'Exact name found but parent did not match (REQUIRE_PARENT_MATCH=true).';\n  } else if (strict && allowContains === false) {\n    note = 'No exact match found and contains-fallback is disabled.';\n  } else {\n    note = 'No matching database found.';\n  }\n}\n\n// Prepare output\nreturn [{\n  json: {\n    db_exists,                                // <— used by the next node\n    found_db_id: chosen?.id || null,\n    found_db_url: chosen?.url || null,\n    found_title: chosen ? titleOf(chosen) : null,\n    found_parent_page_id: chosen ? parentPageOf(chosen) : null,\n    resolved_as, // 'exact' | 'contains' | null\n    candidates_seen,\n    inspected_count: onlyDB.length,\n    // convenience/debugging\n    requested_name: wantName,\n    require_parent_match: requireParent,\n    matched_parent,\n    note\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        80
      ],
      "id": "931dbbad-1560-4935-aacf-388a5a096275",
      "name": "pick_db_by_name"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "8f9e0fac-0e22-4534-841f-1467b1c258fd",
                    "leftValue": "={{ $json.route.index }}",
                    "rightValue": 0,
                    "operator": {
                      "type": "number",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "START_HAS_DB"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "d8c533b4-2532-4fbf-ad93-cc258facb921",
                    "leftValue": "={{ $json.route.index }}",
                    "rightValue": 1,
                    "operator": {
                      "type": "number",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "NO_START_NO_DB"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c477a278-5a19-4c6e-82f6-372dad011dd3",
                    "leftValue": "={{ $json.route.index }}",
                    "rightValue": 2,
                    "operator": {
                      "type": "number",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "START_NO_DB"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f25939c1-a91b-495c-96be-2887c26948eb",
                    "leftValue": "={{ $json.route.index }}",
                    "rightValue": 3,
                    "operator": {
                      "type": "number",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "NO_START_HAS_DB"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1088,
        48
      ],
      "id": "44ef6cce-2ece-4a3f-8a46-21b8725ac3f9",
      "name": "Switch"
    },
    {
      "parameters": {
        "jsCode": "// build_error_text\n// Handles two cases for your 4-way Switch:\n// 1) /start & DB exists  → say \"already connected\"\n// 2) not /start & no DB   → say \"please run /start\"\n//\n// Assumes the workflow provides:\n//  - init_config      → $items('init_config')[0].json\n//  - compose_db_ctx   → $items('compose_db_route_ctx')[0].json  (db_exists, database_id, database_url)\n//  - Telegram Trigger message in $json.message\n\nconst ini   = $items('init_config')[0]?.json ?? {};\nconst ctx   = $items('compose_db_route_ctx')[0]?.json ?? {};\nconst msg   = $json.message || {};\nconst textIn = (msg.text || msg.caption || '').trim();\n\nconst isStart = textIn.startsWith('/start');\nconst hasDb   = !!ctx.db_exists;\n\nconst dbName  = ini.NOTION_DB_NAME || 'ScreenSave';\nconst dbId    = ctx.database_id || null;\nconst dbUrl   = ctx.database_url || null;\n\nlet text;\n\n// Case 1: /start & DB exists\nif (isStart && hasDb) {\n  text = [\n    '✅ <b>Database already connected</b>',\n    `<b>Name:</b> ${dbName}`,\n    dbId ? `<b>ID:</b> <code>${dbId}</code>` : null,\n    dbUrl ? `<a href=\"${dbUrl}\">Open in Notion</a>` : null\n  ].filter(Boolean).join('\\n');\n\n// Case 2: not /start & no DB\n} else if (!isStart && !hasDb) {\n  text = [\n    '⚠️ <b>Database is not set up yet</b>',\n    `This workspace doesn’t have <b>${dbName}</b>.`,\n    'Send <code>/start</code> to create and connect it.',\n  ].join('\\n');\n\n// Fallback (if node was wired to an unexpected branch)\n} else {\n  text = 'ℹ️ Nothing to report.';\n}\n\nreturn [{\n  json: {\n    chat_id: msg?.chat?.id,\n    text,\n    parse_mode: ini.TELEGRAM_PARSE_MODE || 'HTML',\n    disable_web_page_preview: true,\n\n    // Optional: uncomment to include an inline “/start” button when DB is missing\n    // reply_markup: (!isStart && !hasDb) ? {\n    //   inline_keyboard: [[{ text: 'Run /start', callback_data: 'start', }]]\n    // } : undefined,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1328,
        32
      ],
      "id": "68276a38-c800-443e-b8ca-861d5c0bed75",
      "name": "build_error_text"
    },
    {
      "parameters": {
        "content": "## NEW base creation after /start",
        "height": 256,
        "width": 1024,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        272
      ],
      "typeVersion": 1,
      "id": "b17176ff-3606-4829-b9ff-a03e8039c282",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "content": "## Starting\n",
        "height": 256,
        "width": 1024
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1,
      "id": "206a7c01-cb90-4c3e-bf6e-c72817432406",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "## ERROR\n",
        "height": 256,
        "width": 864,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1040,
        0
      ],
      "typeVersion": 1,
      "id": "0be97083-6bf0-474f-965c-76399d9ae68e",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "jsCode": "// build_post_create_message\n// Purpose: send a friendly confirmation after the Notion DB was created.\n//\n// Assumptions:\n// - This node sits right after your Notion \"Create Database\" (current item has DB data),\n//   OR you have that node named \"notion.create_db\" and we can read $items('notion.create_db')[0].json.\n// - init_config node exists with NOTION_DB_NAME and TELEGRAM_PARSE_MODE.\n// - Telegram Trigger node is named \"Start\" (fallbacks included).\n//\n// Output:\n// - { chat_id, text, parse_mode, disable_web_page_preview, reply_markup }\n\nfunction firstJsonFrom(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    if (Array.isArray(arr) && arr.length && arr[0]?.json) return arr[0].json;\n  } catch (_) {}\n  return null;\n}\n\n// 1) Config\nconst ini  = $items('init_config')[0]?.json ?? {};\nconst parseMode = ini.TELEGRAM_PARSE_MODE || 'HTML';\n\n// 2) Telegram chat (from trigger)\nconst tg = firstJsonFrom('Start')\n       || firstJsonFrom('Telegram Trigger')\n       || firstJsonFrom('Telegram')\n       || $json;\nconst chatId =\n  tg?.message?.chat?.id ??\n  tg?.callback_query?.message?.chat?.id ??\n  tg?.channel_post?.chat?.id ??\n  tg?.chat?.id;\n\n// 3) DB creation result (current item first, fallback to a named node)\nconst created = $json?.body || $json; // many Notion nodes return data under body\nconst createdDb = created?.id\n  ? created\n  : (firstJsonFrom('notion.create_db') ?? {});\n\nconst dbId  = createdDb?.id || createdDb?.database_id || null;\nconst dbUrl = createdDb?.url || createdDb?.database_url || null;\n\n// 4) Expected name from compose_db_ctx (optional) or init_config\nconst ctx = firstJsonFrom('compose_db_ctx') ?? {};\nconst dbName =\n  ctx?.expected_name ||\n  ini.NOTION_DB_NAME ||\n  createdDb?.title?.[0]?.plain_text ||\n  'ScreenSave';\n\n// 5) Message text\nconst lines = [\n  '🎉 <b>Database created successfully</b>',\n  `<b>Name:</b> ${dbName}`,\n  dbId ? `<b>ID:</b> <code>${dbId}</code>` : null,\n  dbUrl ? `<a href=\"${dbUrl}\">Open in Notion</a>` : null,\n  '',\n  'You can now start sending items. Use <code>/help</code> for commands.'\n].filter(Boolean);\n\nconst text = lines.join('\\n');\n\n// 6) Optional inline buttons\nconst reply_markup = {\n  inline_keyboard: [\n    ...(dbUrl ? [[{ text: 'Open in Notion', url: dbUrl }]] : []),\n    [{ text: 'Add first item', callback_data: 'add_first_item' }]\n  ]\n};\n\nreturn [{\n  json: {\n    chat_id: chatId,\n    text,\n    parse_mode: parseMode,\n    disable_web_page_preview: false,\n    reply_markup\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        368
      ],
      "id": "a0cfcaa9-eb85-4ebb-a72c-86043a48c2cc",
      "name": "build_post_create_msg"
    },
    {
      "parameters": {
        "chatId": "={{ $node['Start'].json.message.chat.id }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "appendAttribution": false,
          "disable_web_page_preview": true,
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1520,
        32
      ],
      "id": "3bab00f6-0956-42be-833a-61e80321873b",
      "name": "msg_error",
      "webhookId": "567999a8-5a53-4a71-b65e-6d0da62fcf2c",
      "credentials": {
        "telegramApi": {
          "id": "VOYibrgljcdGx8q9",
          "name": "ScreenNotes"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $json.chat_id }}",
        "text": "={{ $json.text }}",
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "={{ $json.reply_markup.inline_keyboard[0][0].text }}",
                    "additionalFields": {
                      "url": "={{ $json.reply_markup.inline_keyboard[0][0].url }}"
                    }
                  }
                ]
              }
            }
          ]
        },
        "additionalFields": {
          "appendAttribution": false,
          "disable_web_page_preview": "={{ $json.disable_web_page_preview }}",
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        672,
        368
      ],
      "id": "18794570-4f02-4199-800d-3ed1c18a5516",
      "name": "msg_base_created",
      "webhookId": "69a76c0d-874c-415b-9b17-7e9966587947",
      "credentials": {
        "telegramApi": {
          "id": "VOYibrgljcdGx8q9",
          "name": "ScreenNotes"
        }
      }
    },
    {
      "parameters": {
        "resource": "image",
        "operation": "analyze",
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "text": "={{ $json.prompt_text }}",
        "imageUrls": "={{ $node['build_tgURL'].json.tg_file_url }}",
        "options": {
          "detail": "auto",
          "maxTokens": 600
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1312,
        608
      ],
      "id": "b3da00ce-ad1f-42ad-be02-2b86a09efd95",
      "name": "analyze_image",
      "credentials": {
        "openAiApi": {
          "id": "ZwMWviwZbVHCaghy",
          "name": "OpenAi"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Function node: extract_json (robust)\n * Достаёт JSON из ответа OpenAI даже если нет закрывающих ``` и/или обрыв в конце.\n * Вход: любой ответ OpenAI; Выход: {…} или {_error, reason, raw, extracted}.\n */\n\nfunction pickContent(obj) {\n  if (obj?.choices?.[0]?.message?.content != null) return obj.choices[0].message.content;\n  if (obj?.data?.choices?.[0]?.message?.content != null) return obj.data.choices[0].message.content;\n  if (obj?.message?.content != null) return obj.message.content;\n  if (obj?.content != null) return obj.content;\n  return null;\n}\n\nlet content = pickContent($json);\n\n// склеим массивные куски, если вдруг пришло частями\nif (Array.isArray(content)) {\n  content = content.map(p => typeof p === 'string' ? p : (p?.text ?? p?.content ?? '')).join('');\n}\nif (typeof content !== 'string' || !content.trim()) {\n  return [{ json: { _error: 'No textual content', raw: $json } }];\n}\n\n// 1) убираем открывающий ```json (даже без закрытия)\nlet text = content.replace(/^\\s*```(?:json|jsonc)?\\s*/i, '')\n                  .replace(/\\s*```+\\s*$/i, '') // если закрытие есть — срежем\n                  .replace(/^\\uFEFF/, '')\n                  .trim();\n\n// 2) оставим только с первого символа { или [\nconst start = text.search(/[\\[{]/);\nif (start >= 0) text = text.slice(start);\n\n// 3) санитайзер: удаляем висячие запятые и балансируем скобки (игнорируя то, что внутри строк)\nfunction sanitize(s) {\n  // уберём висячую запятую перед закрывающей скобкой\n  s = s.replace(/,\\s*([}\\]])/g, '$1');\n  // уберём хвост вроде ,\", ,', , и т.п. в самом конце\n  s = s.replace(/,?\\s*[\"']?\\s*$/,'');\n  const stack = [];\n  let out = '';\n  let inStr = false, esc = false;\n  for (let i = 0; i < s.length; i++) {\n    const ch = s[i];\n    out += ch;\n    if (esc) { esc = false; continue; }\n    if (ch === '\\\\') { if (inStr) esc = true; continue; }\n    if (ch === '\"') { inStr = !inStr; continue; }\n    if (inStr) continue;\n    if (ch === '{' || ch === '[') stack.push(ch);\n    else if (ch === '}' || ch === ']') {\n      const open = stack.pop();\n      if (open && ((open === '{' && ch !== '}') || (open === '[' && ch !== ']'))) {\n        out = out.slice(0, -1) + (open === '{' ? '}' : ']');\n      }\n    }\n  }\n  while (stack.length) {\n    const open = stack.pop();\n    out += (open === '{' ? '}' : ']');\n  }\n  return out.trim();\n}\n\nconst body = sanitize(text);\n\ntry {\n  const obj = JSON.parse(body);\n  return [{ json: obj }];\n} catch (e) {\n  return [{ json: { _error: 'JSON parse failed', reason: e.message, raw: content, extracted: body } }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        608
      ],
      "id": "949ff85e-651f-4cb5-a66e-3b778046a2ef",
      "name": "parse_JSON",
      "executeOnce": false
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "={{ $json.NOTION_DATABASE_ID }}",
          "mode": "id"
        },
        "returnAll": true,
        "filterType": "manual",
        "filters": {
          "conditions": [
            {
              "key": "UID|rich_text",
              "condition": "equals",
              "richTextValue": "={{ $json.UID }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        912,
        1264
      ],
      "id": "ddd039de-33b5-4855-b250-24052832b749",
      "name": "check_for_many",
      "alwaysOutputData": true,
      "credentials": {
        "notionApi": {
          "id": "Hgz4VjhgDGltHZco",
          "name": "Notion_ScreenNotes"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// build_notion_search_body\nconst ini = $items('init_config')[0].json;\nreturn [{\n  json: {\n    query: ini.NOTION_DB_NAME,\n    filter: { value: \"database\", property: \"object\" },\n    page_size: ini.NOTION_SEARCH_LIMIT || 10,\n    sort: { direction: \"descending\", timestamp: \"last_edited_time\" }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        80
      ],
      "id": "ba28953f-ec01-43e6-8565-d09a0b5d7f17",
      "name": "code_search_db"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.notion.com/v1/search",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Notion-Version",
              "value": "={{$items('init_config')[0].json.NOTION_VERSION || \"2022-06-28\"}}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={{$json}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        448,
        80
      ],
      "id": "a0b45442-5ba9-439e-b3cf-c71cc2d88d23",
      "name": "notion_search_db",
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLsgLtaE3BqffWDF",
          "name": "NotionRaw"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "4ee8c2db-fd5b-401c-a451-c85ad57a07ab",
              "leftValue": "={{ ($items(\"check_for_many\") || []).filter(i => i.json?.id).length }}\n\n\n",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1072,
        1264
      ],
      "id": "b94479f1-ec3b-461d-bbc5-8e74427791f6",
      "name": "if_entry_exist"
    },
    {
      "parameters": {
        "chatId": "={{ $json.chat_id }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        2016,
        1248
      ],
      "id": "a6aaa995-6805-42bc-8d46-5ac517af7185",
      "name": "msg_response",
      "webhookId": "9f6057dc-1afb-4e31-9c87-d120ee8c2099",
      "credentials": {
        "telegramApi": {
          "id": "VOYibrgljcdGx8q9",
          "name": "ScreenNotes"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// compose_db_ctx: builds DB context + routing for Switch\n\nconst ini  = $items('init_config')[0]?.json ?? {};\nconst pick = $items('pick_db_by_name')[0]?.json ?? {};\n\nconst database_id   = pick.found_db_id ?? null;\nconst database_url  = pick.found_db_url ?? null;\nconst db_exists     = !!pick.db_exists;\nconst expected_name = ini.NOTION_DB_NAME || 'ScreenSave';\n\n// --- safely read the Telegram trigger payload ---\nfunction firstJsonFrom(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    if (Array.isArray(arr) && arr.length && arr[0]?.json) return arr[0].json;\n  } catch (_) {}\n  return null;\n}\n\n// Try common names you might have on canvas\nconst tgSource =\n  firstJsonFrom('Start') ||\n  firstJsonFrom('Telegram Trigger') ||\n  firstJsonFrom('Telegram') ||\n  firstJsonFrom('is_start_cmd') ||\n  $json; // fallback to current item\n\nconst textRaw =\n  tgSource?.message?.text ??\n  tgSource?.message?.caption ??\n  tgSource?.callback_query?.data ??\n  tgSource?.channel_post?.text ??\n  tgSource?.edited_message?.text ??\n  '';\n\nconst text   = String(textRaw).trim();\n// match \"/start\" or \"/start anything\"\nconst isStart = /^\\/start(\\s|$)/i.test(text);\n\n// --- route (Switch outputs 0..3) ---\n// 0: /start & yes DB\n// 1: not /start & no DB\n// 2: /start & no DB\n// 3: not /start & yes DB\nconst index = isStart ? (db_exists ? 0 : 2) : (db_exists ? 3 : 1);\nconst label =\n  index === 0 ? 'START_HAS_DB' :\n  index === 1 ? 'NO_START_NO_DB' :\n  index === 2 ? 'START_NO_DB' :\n                'NO_START_HAS_DB';\n\nreturn [{\n  json: {\n    database_id,\n    database_url,\n    db_exists,\n    resolved_by: pick.resolved_by ?? 'compose_db_ctx',\n    expected_name,\n    route: { isStart, hasDb: db_exists, index, label, text }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        80
      ],
      "id": "4e6972d4-33f7-4026-93c4-542dfadef9bb",
      "name": "compose_db_route_ctx"
    },
    {
      "parameters": {
        "jsCode": "/**\n * build_dynamic_prompt (Simplified)\n * Uses the simplified init_config structure\n */\n\nconst cfg = $items('init_config')?.[0]?.json || {};\n\n// Build prompt from simplified structure\nconst typeOptions = cfg.TYPE_OPTIONS?.Type?.select?.options?.map(o => o.name).join(', ') || 'Product,Contact,Event,Note';\nconst typePrompt = cfg.TYPE_OPTIONS?.Type?.prompt || 'Classify the screenshot.';\n\nconst fieldPrompts = Object.entries(cfg.FIELDS || {})\n  .map(([name, prompt]) => `- ${name}: ${prompt}`)\n  .join('\\n');\n\nconst perTypeGuides = Object.entries(cfg.PER_TYPE || {})\n  .map(([type, fields]) => {\n    const fieldLines = Object.entries(fields)\n      .map(([k, v]) => `    - ${k}: ${v.prompt}`)\n      .join('\\n');\n    return `  ${type}:\\n${fieldLines}`;\n  })\n  .join('\\n');\n\nconst baseSchema = Object.entries(cfg.OUTPUT_SCHEMA?.base || {})\n  .map(([k, v]) => `  \"${k}\": \"${v}\"`)\n  .join(',\\n');\n\nconst prompt_text = `\nYou are a screenshot cataloging assistant. Return STRICT valid JSON and nothing else.\n\nType classification (one of: ${typeOptions}):\n${typePrompt}\n\nFields (what to put into each):\n${fieldPrompts}\n\nAdditional fields by type:\n${perTypeGuides}\n\nSchema:\n{\n${baseSchema}\n}\n\nRequirements:\n- If some data is missing, use null and decrease confidence.\n- Output MUST be pure JSON only. No explanations, no extra text.\n\nLANGUAGE POLICY (strict):\n- ${cfg.POLICY?.language || 'Output language = dominant OCR language; never translate.'}\n- ${cfg.POLICY?.missing || 'If a value is not on the screenshot, set it to null and decrease confidence.'}\n- ${cfg.POLICY?.scriptsGuard || 'Do not output ko/ja/zh unless those scripts appear in the screenshot.'}\n`.trim();\n\nreturn [{ json: { prompt_text } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        608
      ],
      "id": "0df9068f-b55d-48ea-96e4-c8b7872f4fcf",
      "name": "build_dynamic_prompt"
    },
    {
      "parameters": {
        "content": "## SERPapi Enrichment (MAP link creation) \n",
        "height": 272,
        "width": 1024,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        16,
        832
      ],
      "typeVersion": 1,
      "id": "eb764686-a197-4293-bb95-826c4fe0ea89",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "jsCode": "// enrichment_router.js\nconst data = $json || {};\nconst config = $items('init_config')?.[0]?.json || {};\n\n// Check if enrichment is enabled\nif (!config.ENABLE_ENRICHMENT) {\n  return [{ json: { ...data, enrichment_needed: false } }];\n}\n\n// Only process Contact and Event types\nif (!['Contact', 'Event'].includes(data.Type)) {\n  return [{ json: { ...data, enrichment_needed: false } }];\n}\n\nconst enhancedData = { ...data };\nlet enrichmentNeeded = false;\nlet searchQuery = null;\nlet enrichmentType = null;\n\n// === CONTACT ENRICHMENT ===\nif (data.Type === 'Contact') {\n  const hasAddress = data.contact_Address && data.contact_Address !== 'null' && data.contact_Address.trim() !== '';\n  const hasTitle = data.Title && data.Title !== 'null' && data.Title.trim() !== '';\n  \n  // Check if maps URL already exists and is valid\n  const hasValidMapUrl = data.contact_mapURL && data.contact_mapURL.includes('google.com/maps');\n  \n  if ((hasAddress || hasTitle) && !hasValidMapUrl) {\n    searchQuery = generateContactSearchQuery(data);\n    enrichmentType = 'contact_maps';\n    enrichmentNeeded = true;\n  }\n}\n\n// === EVENT ENRICHMENT ===\nif (data.Type === 'Event') {\n  const hasAddress = data.event_Adddress && data.event_Adddress !== 'null' && data.event_Adddress.trim() !== '';\n  const hasTitle = data.Title && data.Title !== 'null' && data.Title.trim() !== '';\n  const hasDate = data.event_DateStart && data.event_DateStart !== 'null';\n  \n  // Check if event URL already exists\n  const hasValidEventUrl = data.event_AddressURL && data.event_AddressURL !== 'null';\n  \n  if ((hasAddress || hasTitle) && !hasValidEventUrl) {\n    searchQuery = generateEventSearchQuery(data);\n    enrichmentType = 'event_url';\n    enrichmentNeeded = true;\n  }\n}\n\nif (!enrichmentNeeded) {\n  return [{ json: { ...data, enrichment_needed: false } }];\n}\n\n// Prepare enrichment configuration\nconst enrichmentConfig = {\n  api_key: config.SERPAPI_API_KEY,\n  engine: 'google',\n  country: 'us',\n  language: 'en',\n  num: 5,\n  safe: 'active'\n};\n\n// Add specific parameters based on enrichment type\nif (enrichmentType === 'contact_maps') {\n  enrichmentConfig.tbm = 'lcl'; // Local business results\n} else if (enrichmentType === 'event_url') {\n  enrichmentConfig.tbs = 'qdr:m'; // Past month for events\n}\n\nreturn [{\n  json: {\n    ...enhancedData,\n    enrichment_needed: true,\n    enrichment_query: searchQuery,\n    enrichment_type: enrichmentType,\n    enrichment_config: enrichmentConfig\n  }\n}];\n\nfunction generateContactSearchQuery(data) {\n  // Priority 1: Title + Address (most specific)\n  if (data.Title && data.contact_Address) {\n    return `${data.Title} ${data.contact_Address}`;\n  }\n  \n  // Priority 2: Just address\n  if (data.contact_Address) {\n    return `${data.contact_Address} location`;\n  }\n  \n  // Priority 3: Title + generic location\n  if (data.Title) {\n    return `${data.Title} business location`;\n  }\n  \n  return null;\n}\n\nfunction generateEventSearchQuery(data) {\n  // Priority 1: Title + Address + Date (most specific)\n  if (data.Title && data.event_Adddress && data.event_DateStart) {\n    return `${data.Title} ${data.event_Adddress} ${data.event_DateStart}`;\n  }\n  \n  // Priority 2: Title + Address\n  if (data.Title && data.event_Adddress) {\n    return `${data.Title} ${data.event_Adddress} event`;\n  }\n  \n  // Priority 3: Title + Date\n  if (data.Title && data.event_DateStart) {\n    return `${data.Title} ${data.event_DateStart} event`;\n  }\n  \n  // Priority 4: Just title\n  if (data.Title) {\n    return `${data.Title} event`;\n  }\n  \n  return null;\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        928
      ],
      "id": "59e2a218-ff90-40e8-bd96-360a6a8549dc",
      "name": "enrichment_router"
    },
    {
      "parameters": {
        "jsCode": "// url_generator.js - ENHANCED FOR MULTIPLE ADDRESSES\nconst serpApiResponse = $json || {};\n\n// Get the original data from enrichment_router\nconst originalData = $items('enrichment_router')?.[0]?.json || {};\n\nconsole.log('=== DEBUG INFO ===');\nconsole.log('SerpApi Response keys:', Object.keys(serpApiResponse));\nconsole.log('Original Data keys:', Object.keys(originalData));\nconsole.log('Enrichment needed:', originalData.enrichment_needed);\nconsole.log('Enrichment type:', originalData.enrichment_type);\n\n// If enrichment wasn't needed, pass through original data\nif (!originalData.enrichment_needed) {\n  console.log('Enrichment not needed, passing through original data');\n  return [{ json: originalData }];\n}\n\n// If SerpApi request failed, return original data\nif (serpApiResponse.error) {\n  console.warn('SerpApi request failed:', serpApiResponse.error);\n  return [{ json: originalData }];\n}\n\n// Start with original data\nconst enhancedData = { ...originalData };\n\ntry {\n  const enrichmentType = originalData.enrichment_type;\n  console.log('Processing enrichment type:', enrichmentType);\n  \n  if (enrichmentType === 'contact_maps') {\n    console.log('Processing contact maps enrichment...');\n    \n    // Get local results from SerpApi\n    const localResults = serpApiResponse.local_results || [];\n    console.log('Found local results:', localResults.length);\n    \n    if (localResults.length > 0) {\n      // Find the best matching result\n      const bestResult = findBestMatch(originalData, localResults);\n      console.log('Best match found:', bestResult.title, bestResult.address);\n      \n      // Check for GPS coordinates\n      if (bestResult.gps_coordinates) {\n        const lat = bestResult.gps_coordinates.latitude;\n        const lng = bestResult.gps_coordinates.longitude;\n        console.log('GPS coordinates:', lat, lng);\n        \n        // Generate Google Maps URL\n        const mapsUrl = `https://www.google.com/maps/place/${lat},${lng}`;\n        console.log('Generated maps URL:', mapsUrl);\n        \n        // Update the contact_mapURL\n        enhancedData.contact_mapURL = mapsUrl;\n        console.log('Set contact_mapURL to:', enhancedData.contact_mapURL);\n        \n        // Update confidence based on match quality\n        const matchScore = calculateMatchScore(originalData, bestResult);\n        enhancedData.Confidence = Math.min((enhancedData.Confidence || 0.5) + (matchScore * 0.2), 1.0);\n        \n        // Add enrichment metadata\n        enhancedData.enrichment_status = 'completed';\n        enhancedData.enrichment_source = 'serpapi';\n        enhancedData.enrichment_match_score = matchScore;\n        enhancedData.enrichment_total_results = localResults.length;\n        \n      } else {\n        console.log('No GPS coordinates found');\n      }\n    } else {\n      console.log('No local results found');\n    }\n    \n  } else if (enrichmentType === 'event_url') {\n    console.log('Processing event URL enrichment...');\n    // Event processing logic here\n  }\n  \n} catch (error) {\n  console.warn('URL generation failed:', error.message);\n  console.error('Full error:', error);\n}\n\nconsole.log('Final enhanced data contact_mapURL:', enhancedData.contact_mapURL);\nreturn [{ json: enhancedData }];\n\nfunction findBestMatch(originalData, localResults) {\n  console.log('=== FINDING BEST MATCH ===');\n  console.log('Original title:', originalData.Title);\n  console.log('Original address:', originalData.contact_Address);\n  \n  let bestMatch = localResults[0]; // Default to first result\n  let bestScore = 0;\n  \n  localResults.forEach((result, index) => {\n    const score = calculateMatchScore(originalData, result);\n    console.log(`Result ${index + 1}: \"${result.title}\" at \"${result.address}\" - Score: ${score}`);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = result;\n    }\n  });\n  \n  console.log('Best match selected:', bestMatch.title, 'with score:', bestScore);\n  return bestMatch;\n}\n\nfunction calculateMatchScore(originalData, result) {\n  let score = 0;\n  \n  // Title matching (highest priority)\n  if (originalData.Title && result.title) {\n    const originalTitle = originalData.Title.toLowerCase();\n    const resultTitle = result.title.toLowerCase();\n    \n    // Exact match\n    if (originalTitle === resultTitle) {\n      score += 10;\n    }\n    // Contains match\n    else if (resultTitle.includes(originalTitle) || originalTitle.includes(resultTitle)) {\n      score += 8;\n    }\n    // Partial word match\n    else {\n      const originalWords = originalTitle.split(/\\s+/);\n      const resultWords = resultTitle.split(/\\s+/);\n      const commonWords = originalWords.filter(word => \n        word.length > 2 && resultWords.some(rWord => rWord.includes(word))\n      );\n      score += commonWords.length * 2;\n    }\n  }\n  \n  // Address matching\n  if (originalData.contact_Address && result.address) {\n    const originalAddress = originalData.contact_Address.toLowerCase();\n    const resultAddress = result.address.toLowerCase();\n    \n    // Exact address match\n    if (originalAddress === resultAddress) {\n      score += 5;\n    }\n    // Contains match\n    else if (resultAddress.includes(originalAddress) || originalAddress.includes(resultAddress)) {\n      score += 3;\n    }\n    // Partial match\n    else {\n      const originalWords = originalAddress.split(/[\\s,]+/);\n      const resultWords = resultAddress.split(/[\\s,]+/);\n      const commonWords = originalWords.filter(word => \n        word.length > 2 && resultWords.some(rWord => rWord.includes(word))\n      );\n      score += commonWords.length;\n    }\n  }\n  \n  // Rating bonus (higher rated places get slight preference)\n  if (result.rating && result.rating >= 4.0) {\n    score += 1;\n  }\n  \n  // Review count bonus (more reviews = more established)\n  if (result.reviews && result.reviews >= 100) {\n    score += 0.5;\n  }\n  \n  console.log(`Match score breakdown for \"${result.title}\":`, {\n    titleMatch: score >= 8 ? 'High' : score >= 4 ? 'Medium' : 'Low',\n    addressMatch: score >= 5 ? 'High' : score >= 3 ? 'Medium' : 'Low',\n    totalScore: score\n  });\n  \n  return score;\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        928
      ],
      "id": "75705ffe-d1c4-4cb1-9dd4-2f463db3e83b",
      "name": "url_generator"
    },
    {
      "parameters": {
        "url": "https://serpapi.com/search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "api_key",
              "value": "={{ $json.enrichment_config.api_key }}"
            },
            {
              "name": "q",
              "value": "={{ $json.enrichment_query }}"
            },
            {
              "name": "engine",
              "value": "={{ $json.enrichment_config.engine }}"
            },
            {
              "name": "country",
              "value": "={{ $json.enrichment_config.country }}"
            },
            {
              "name": "language",
              "value": "={{ $json.enrichment_config.language }}"
            },
            {
              "name": "num",
              "value": "={{ $json.enrichment_config.num }}"
            },
            {
              "name": "safe",
              "value": "={{ $json.enrichment_config.safe }}"
            },
            {
              "name": "tbm",
              "value": "={{ $json.enrichment_config.tbm }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 15000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        272,
        928
      ],
      "id": "21a1a064-c866-4901-bce8-267685009971",
      "name": "serpapi_search1"
    }
  ],
  "pinData": {
    "Start": [
      {
        "json": {
          "update_id": 965371470,
          "message": {
            "message_id": 100,
            "from": {
              "id": 394819858,
              "is_bot": false,
              "first_name": "Mikhail",
              "last_name": "Belov",
              "username": "mic_belov",
              "language_code": "ru"
            },
            "chat": {
              "id": 394819858,
              "first_name": "Mikhail",
              "last_name": "Belov",
              "username": "mic_belov",
              "type": "private"
            },
            "date": 1760994735,
            "photo": [
              {
                "file_id": "AgACAgIAAxkBAANkaPalr1ID9R2tF2LG_kbeDFWg3NgAAgX6MRsJ_rFLfNppuypvR9cBAAMCAANzAAM2BA",
                "file_unique_id": "AQADBfoxGwn-sUt4",
                "file_size": 1170,
                "width": 42,
                "height": 90
              },
              {
                "file_id": "AgACAgIAAxkBAANkaPalr1ID9R2tF2LG_kbeDFWg3NgAAgX6MRsJ_rFLfNppuypvR9cBAAMCAANtAAM2BA",
                "file_unique_id": "AQADBfoxGwn-sUty",
                "file_size": 14788,
                "width": 148,
                "height": 320
              },
              {
                "file_id": "AgACAgIAAxkBAANkaPalr1ID9R2tF2LG_kbeDFWg3NgAAgX6MRsJ_rFLfNppuypvR9cBAAMCAAN4AAM2BA",
                "file_unique_id": "AQADBfoxGwn-sUt9",
                "file_size": 60773,
                "width": 369,
                "height": 800
              },
              {
                "file_id": "AgACAgIAAxkBAANkaPalr1ID9R2tF2LG_kbeDFWg3NgAAgX6MRsJ_rFLfNppuypvR9cBAAMCAAN5AAM2BA",
                "file_unique_id": "AQADBfoxGwn-sUt-",
                "file_size": 100005,
                "width": 590,
                "height": 1280
              }
            ]
          }
        }
      }
    ]
  },
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "init_config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "extract_file_id": {
      "main": [
        [
          {
            "node": "getFile",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "getFile": {
      "main": [
        [
          {
            "node": "build_tgURL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "downloadFile": {
      "main": [
        [
          {
            "node": "Crypto",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "normalize_for_notion": {
      "main": [
        [
          {
            "node": "gd_input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_tg_message": {
      "main": [
        [
          {
            "node": "msg_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_create_payload": {
      "main": [
        [
          {
            "node": "notion_create",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "notion_create": {
      "main": [
        [
          {
            "node": "build_tg_message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_update_payload": {
      "main": [
        [
          {
            "node": "notion_create",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_tgURL": {
      "main": [
        [
          {
            "node": "downloadFile",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Crypto": {
      "main": [
        [
          {
            "node": "build_dynamic_prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "call_gdrive_flow": {
      "main": [
        [
          {
            "node": "gd_output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gd_input": {
      "main": [
        [
          {
            "node": "call_gdrive_flow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gd_output": {
      "main": [
        [
          {
            "node": "check_for_many",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "init_config": {
      "main": [
        [
          {
            "node": "code_search_db",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_db_create payload": {
      "main": [
        [
          {
            "node": "notion_create_db",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "pick_db_by_name": {
      "main": [
        [
          {
            "node": "compose_db_route_ctx",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "build_error_text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "build_error_text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "build_db_create payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "extract_file_id",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_error_text": {
      "main": [
        [
          {
            "node": "msg_error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "notion_create_db": {
      "main": [
        [
          {
            "node": "build_post_create_msg",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_post_create_msg": {
      "main": [
        [
          {
            "node": "msg_base_created",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "analyze_image": {
      "main": [
        [
          {
            "node": "parse_JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "parse_JSON": {
      "main": [
        [
          {
            "node": "enrichment_router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_for_many": {
      "main": [
        [
          {
            "node": "if_entry_exist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "code_search_db": {
      "main": [
        [
          {
            "node": "notion_search_db",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "notion_search_db": {
      "main": [
        [
          {
            "node": "pick_db_by_name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "if_entry_exist": {
      "main": [
        [
          {
            "node": "build_update_payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "build_create_payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "compose_db_route_ctx": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_dynamic_prompt": {
      "main": [
        [
          {
            "node": "analyze_image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "enrichment_router": {
      "main": [
        [
          {
            "node": "serpapi_search1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "url_generator": {
      "main": [
        [
          {
            "node": "normalize_for_notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "serpapi_search1": {
      "main": [
        [
          {
            "node": "url_generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "5244b4b9-6f9f-4829-b7df-6aa0d1ff87d0",
  "meta": {
    "instanceId": "f33670e28fdef979b6323e05880f1cf7e274dd2d46f8c9cc3a50caad9241c1e2"
  },
  "id": "5VQTBLRU5ZQEVOjN",
  "tags": [
    {
      "createdAt": "2025-06-20T09:55:51.417Z",
      "updatedAt": "2025-06-20T09:55:51.417Z",
      "id": "buzWDBiL7XyI4bpf",
      "name": "GDrive"
    },
    {
      "createdAt": "2025-06-20T09:57:00.063Z",
      "updatedAt": "2025-06-20T09:57:00.063Z",
      "id": "HmThOLiZNW7fkmdA",
      "name": "OpenAI"
    },
    {
      "createdAt": "2025-09-29T09:22:13.989Z",
      "updatedAt": "2025-09-29T09:22:13.989Z",
      "id": "hV2UD2aQ4IpLoDkS",
      "name": "Notion"
    }
  ]
}